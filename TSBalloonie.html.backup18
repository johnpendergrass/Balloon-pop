<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Balloon Popping Game</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        height: 100vh;
        width: 100vw;
        background-color: #001122;
        font-family: Arial, sans-serif;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        cursor: none; /* Hide default cursor globally, use custom cursor */
      }

      /* Override cursor for interactive elements */
      button, input, label {
        cursor: pointer !important;
      }

      /* Full-screen background container */
      #mainContainer {
        width: 100vw;
        height: 100vh;
        background-color: #001122;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        display: flex;
        flex-direction: column;
      }

      /* Top scoreboard area */
      #scoreboardArea {
        height: 120px;
        width: 100%;
        position: relative;
        z-index: 20;
      }

      /* Chrome separator */
      #chromeSeparator {
        height: 8px;
        width: 100%;
        background: linear-gradient(90deg, 
          #666 0%, #ccc 15%, #fff 30%, #ccc 45%, 
          #999 50%, #ccc 55%, #fff 70%, #ccc 85%, #666 100%);
        box-shadow: 
          0 2px 4px rgba(0,0,0,0.5),
          inset 0 1px 0 rgba(255,255,255,0.8),
          inset 0 -1px 0 rgba(0,0,0,0.3);
        position: relative;
      }

      #chromeSeparator::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
        animation: chrome-shine 2s infinite;
      }

      @keyframes chrome-shine {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
      }

      /* Game area container */
      #gameContainer {
        flex: 1;
        position: relative;
        margin: 10px;
        border: 3px solid #ffffff;
        border-radius: 15px;
        box-shadow: 0 0 30px rgba(255, 255, 255, 0.4);
        overflow: hidden;
      }

      #gameCanvas {
        display: block;
        cursor: none; /* Hide default cursor */
        width: 100%;
        height: 100%;
        border-radius: 12px;
        background: transparent;
      }

      /* Custom Cursor System */
      #customCursor {
        position: fixed;
        pointer-events: none;
        z-index: 10000;
        transform: translate(-50%, 0%);
        transition: opacity 0.2s ease;
        opacity: 1; /* Start visible */
      }

      /* Sharp pointer cursor */
      .cursor-pointer {
        width: 0;
        height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-bottom: 20px solid #ffffff;
        filter: drop-shadow(0 0 3px rgba(0,0,0,0.8)) drop-shadow(0 0 6px #ffffff);
      }

      /* Streak cursor with number */
      .cursor-streak {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .cursor-streak .streak-pointer {
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-bottom: 24px solid #FFD700;
        filter: drop-shadow(0 0 4px rgba(0,0,0,0.8)) drop-shadow(0 0 8px #FFD700);
      }

      .cursor-streak .streak-number {
        background: #FFD700;
        color: #000;
        font-weight: bold;
        font-size: 14px;
        padding: 4px 8px;
        border-radius: 12px;
        margin-top: 4px;
        text-shadow: none;
        box-shadow: 0 0 8px #FFD700;
        min-width: 20px;
        text-align: center;
      }


      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: clamp(24px, 5vw, 48px);
        font-weight: bold;
        text-align: center;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        z-index: 20;
        display: none;
        background: rgba(0, 0, 0, 0.7);
        padding: 30px;
        border-radius: 15px;
        backdrop-filter: blur(10px);
      }

      .restart-btn {
        margin-top: 20px;
        padding: clamp(8px, 2vw, 15px) clamp(15px, 3vw, 25px);
        font-size: clamp(14px, 2.5vw, 20px);
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      .restart-btn:hover {
        background-color: #45a049;
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
      }

      /* ABOUT Button Styling */
      .about-btn {
        margin-top: 8px;
        padding: 6px 12px;
        font-family: 'Comic Sans MS', 'Arial Black', sans-serif;
        font-size: 12px;
        font-weight: bold;
        background: linear-gradient(145deg, #FFD700, #E6C200);
        color: white;
        border: 2px solid transparent;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 
          0 3px 6px rgba(0, 0, 0, 0.2),
          inset 0 1px 2px rgba(255, 255, 255, 0.3);
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        width: 100%;
      }

      .about-btn:hover {
        background: linear-gradient(145deg, #FFDF00, #FFD700);
        transform: translateY(-1px);
      }

      .about-btn:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      /* Amiga System Error Dialog */
      .amiga-dialog {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 9999;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .amiga-dialog-content {
        width: 650px;
        background: #aaaaaa;
        border: 4px solid #ffffff;
        box-shadow: 
          4px 4px 0px #000000,
          inset 2px 2px 0px #ffffff,
          inset -2px -2px 0px #666666;
        font-family: 'Courier New', monospace;
        font-size: 13px;
      }

      .amiga-title-bar {
        background: linear-gradient(90deg, #0055aa, #0077cc);
        color: #ffffff;
        padding: 4px 8px;
        font-weight: bold;
        font-size: 11px;
        text-align: center;
        border-bottom: 2px solid #ffffff;
        text-shadow: 1px 1px 0px #000000;
      }

      .amiga-dialog-body {
        padding: 16px;
        background: #aaaaaa;
        display: flex;
        align-items: center;
        gap: 16px;
        min-height: 80px;
      }

      .amiga-icon {
        font-size: 32px;
        color: #ff6600;
        font-weight: bold;
        text-shadow: 2px 2px 0px #000000;
        min-width: 40px;
        text-align: center;
      }

      .amiga-text {
        flex: 1;
        color: #000000;
        font-weight: bold;
        line-height: 1.4;
        font-family: 'Courier New', monospace;
        text-align: center;
      }

      .amiga-button-bar {
        padding: 12px;
        text-align: center;
        background: #aaaaaa;
        border-top: 2px solid #666666;
      }

      .amiga-button {
        background: #cccccc;
        border: 3px outset #cccccc;
        padding: 6px 20px;
        font-size: 12px;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        cursor: pointer;
        color: #000000;
        min-width: 80px;
        box-shadow: 2px 2px 0px #666666;
      }

      .amiga-button:hover {
        background: #dddddd;
      }

      .amiga-button:active {
        border: 3px inset #cccccc;
        box-shadow: none;
      }

      #levelStart {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: clamp(20px, 4vw, 32px);
        font-weight: bold;
        text-align: center;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        z-index: 25;
      }

      /* Splash screen info box - Toy Story chrome style */
      #splashInfoBox {
        position: fixed;
        bottom: 25px;
        right: calc(2% + 88px);
        background: linear-gradient(145deg, #e8e8e8 0%, #c0c0c0 25%, #d4d4d4 50%, #a8a8a8 75%, #bcbcbc 100%);
        border: 3px solid #666;
        border-radius: 15px;
        padding: 16px 20px;
        box-shadow: 
          inset 0 4px 8px rgba(255, 255, 255, 0.6),
          inset 0 -2px 4px rgba(0, 0, 0, 0.3),
          0 4px 12px rgba(0, 0, 0, 0.4),
          0 2px 6px rgba(0, 0, 0, 0.2);
        text-align: center;
        font-family: 'Comic Sans MS', 'Arial Black', sans-serif;
        z-index: 30;
        min-width: 200px;
        max-width: 250px;
      }

      .info-text {
        color: #2c5282;
        font-size: 14px;
        font-weight: bold;
        margin: 4px 0;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }
      
      .info-text.cheater-active {
        color: #FF0000;
        font-weight: bold;
        animation: pulse 1s infinite;
      }
      
      @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
      }

      /* Sound Mode Box - Similar to Skill Level Box */
      #soundModeBox {
        position: fixed;
        bottom: 25px;
        right: calc(2% + 88px + 270px + 20px); /* Skill box width + gap */
        background: linear-gradient(145deg, #e8e8e8 0%, #c0c0c0 25%, #d4d4d4 50%, #a8a8a8 75%, #bcbcbc 100%);
        border: 3px solid #666;
        border-radius: 15px;
        padding: 16px 20px;
        box-shadow: 
          inset 0 4px 8px rgba(255, 255, 255, 0.6),
          inset 0 -2px 4px rgba(0, 0, 0, 0.3),
          0 4px 12px rgba(0, 0, 0, 0.4),
          0 2px 6px rgba(0, 0, 0, 0.2);
        text-align: center;
        font-family: 'Comic Sans MS', 'Arial Black', sans-serif;
        z-index: 30;
        min-width: 200px;
        max-width: 250px;
        display: none; /* Hidden by default */
      }

      .sound-mode-label {
        color: #2c5282;
        font-family: 'Comic Sans MS', 'Arial Black', sans-serif;
        font-size: 11px;
        font-weight: bold;
        margin-bottom: 6px;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }

      /* Toggle Switch Container */
      .toggle-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        margin-bottom: 12px;
      }

      /* Toggle Track (Switch Plate) */
      .toggle-track {
        width: 120px;
        height: 40px;
        background: linear-gradient(145deg, #f0f0f0, #d0d0d0);
        border: 2px solid #999;
        border-radius: 20px;
        position: relative;
        cursor: pointer;
        box-shadow: 
          inset 0 2px 4px rgba(0, 0, 0, 0.3),
          inset 0 -1px 2px rgba(255, 255, 255, 0.3);
      }

      /* Toggle Slider (Switch Actuator) */
      .toggle-slider {
        width: 50px;
        height: 32px;
        background: linear-gradient(145deg, #ffffff, #e0e0e0);
        border: 1px solid #666;
        border-radius: 16px;
        position: absolute;
        top: 3px;
        transition: left 0.3s ease;
        box-shadow: 
          0 2px 4px rgba(0, 0, 0, 0.3),
          0 1px 2px rgba(0, 0, 0, 0.2);
      }

      .toggle-slider.quiet { 
        left: 4px; 
      }

      .toggle-slider.noisy { 
        left: 66px; 
      }

      .toggle-slider.jiggle {
        animation: jiggle 0.1s ease-in-out 5;
      }

      /* Toggle Labels */
      .toggle-labels {
        display: flex;
        justify-content: space-between;
        width: 120px;
        font-size: 10px;
        font-weight: bold;
        color: #2c5282;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }

      /* Jiggle Animation */
      @keyframes jiggle {
        0% { transform: translateX(0); }
        25% { transform: translateX(-3px); }
        50% { transform: translateX(3px); }
        75% { transform: translateX(-2px); }
        100% { transform: translateX(0); }
      }

      /* Skill level label */
      .skill-level-label {
        color: #2c5282;
        font-family: 'Comic Sans MS', 'Arial Black', sans-serif;
        font-size: 11px;
        font-weight: bold;
        text-align: center;
        margin-bottom: 6px;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }

      /* Difficulty Selection Radio Buttons */
      .difficulty-selection {
        display: flex;
        justify-content: space-between;
        margin-bottom: 12px;
        gap: 8px;
      }

      .radio-option {
        flex: 1;
        cursor: pointer;
        text-align: center;
        padding: 6px 8px;
        border-radius: 8px;
        border: 2px solid transparent;
        font-family: 'Comic Sans MS', 'Arial Black', sans-serif;
        font-size: 12px;
        font-weight: bold;
        transition: all 0.2s ease;
        position: relative;
      }

      .radio-option input[type="radio"] {
        display: none;
      }

      .radio-option span {
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      }

      /* Rex - Green (Easy) */
      .radio-option.rex {
        background: linear-gradient(145deg, #48bb78, #38a169);
        color: white;
        box-shadow: 
          0 3px 6px rgba(0, 0, 0, 0.2),
          inset 0 1px 2px rgba(255, 255, 255, 0.3);
      }

      .radio-option.rex:hover {
        background: linear-gradient(145deg, #68d391, #48bb78);
        transform: translateY(-1px);
      }

      .radio-option.rex input:checked ~ span {
        text-shadow: 0 0 4px rgba(255, 255, 255, 0.8);
      }


      /* Proper selected state for Rex */
      .radio-option.rex:has(input:checked) {
        border: 3px solid #32CD32;
        box-shadow: 
          0 0 8px rgba(50, 205, 50, 0.6),
          0 3px 6px rgba(0, 0, 0, 0.2),
          inset 0 1px 2px rgba(255, 255, 255, 0.3);
        background: linear-gradient(145deg, #48bb78, #38a169);
      }

      /* Woody - Yellow/Brown (Medium) */
      .radio-option.woody {
        background: linear-gradient(145deg, #ed8936, #d69e2e);
        color: white;
        box-shadow: 
          0 3px 6px rgba(0, 0, 0, 0.2),
          inset 0 1px 2px rgba(255, 255, 255, 0.3);
      }

      .radio-option.woody:hover {
        background: linear-gradient(145deg, #f6ad55, #ed8936);
        transform: translateY(-1px);
      }

      .radio-option.woody input:checked + span {
        text-shadow: 0 0 4px rgba(255, 255, 255, 0.8);
      }

      /* Proper selected state for Woody */
      .radio-option.woody:has(input:checked) {
        border: 3px solid #FFD700;
        box-shadow: 
          0 0 8px rgba(255, 215, 0, 0.6),
          0 3px 6px rgba(0, 0, 0, 0.2),
          inset 0 1px 2px rgba(255, 255, 255, 0.3);
        background: linear-gradient(145deg, #ed8936, #d69e2e);
      }

      /* Buzz - Blue (Hard) */
      .radio-option.buzz {
        background: linear-gradient(145deg, #4299e1, #3182ce);
        color: white;
        box-shadow: 
          0 3px 6px rgba(0, 0, 0, 0.2),
          inset 0 1px 2px rgba(255, 255, 255, 0.3);
      }

      .radio-option.buzz:hover {
        background: linear-gradient(145deg, #63b3ed, #4299e1);
        transform: translateY(-1px);
      }

      .radio-option.buzz input:checked + span {
        text-shadow: 0 0 4px rgba(255, 255, 255, 0.8);
      }

      /* Proper selected state for Buzz */
      .radio-option.buzz:has(input:checked) {
        border: 3px solid #00FFFF;
        box-shadow: 
          0 0 8px rgba(0, 255, 255, 0.6),
          0 3px 6px rgba(0, 0, 0, 0.2),
          inset 0 1px 2px rgba(255, 255, 255, 0.3);
        background: linear-gradient(145deg, #4299e1, #3182ce);
      }


      /* Game Summary Box - Toy Story chrome style */
      #gameSummary {
        position: absolute;
        top: 15%;
        right: 2%;
        background: linear-gradient(145deg, #e8e8e8 0%, #c0c0c0 25%, #d4d4d4 50%, #a8a8a8 75%, #bcbcbc 100%);
        border: 4px solid #666;
        border-radius: 20px;
        padding: 24px 30px;
        box-shadow: 
          inset 0 6px 12px rgba(255, 255, 255, 0.6),
          inset 0 -3px 6px rgba(0, 0, 0, 0.3),
          0 6px 20px rgba(0, 0, 0, 0.4),
          0 3px 10px rgba(0, 0, 0, 0.3);
        font-family: 'Comic Sans MS', 'Arial Black', sans-serif;
        z-index: 30;
        min-width: 380px;
        max-width: 450px;
      }

      .summary-header {
        color: #2c5282;
        font-size: 22px;
        font-weight: bold;
        margin-bottom: 16px;
        text-shadow: 0 2px 4px rgba(255, 255, 255, 0.8);
        border-bottom: 2px solid #999;
        padding-bottom: 8px;
      }

      .summary-header-line {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .summary-content {
        color: #2c5282;
        font-size: 16px;
        font-weight: bold;
      }

      .summary-line {
        margin: 8px 0;
        display: flex;
        justify-content: space-between;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }

      .summary-divider {
        height: 2px;
        background: linear-gradient(90deg, transparent, #999, transparent);
        margin: 12px 0;
      }

      .summary-total {
        margin: 12px 0;
        font-size: 18px;
        font-weight: bold;
        color: #d63447;
        text-align: center;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }

      .summary-prior-score {
        margin: 8px 0 4px 0;
        font-size: 16px;
        font-weight: bold;
        color: #d63447;
        text-align: center;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }

      .summary-game-score {
        margin: 4px 0 12px 0;
        font-size: 20px;
        font-weight: bold;
        color: #d63447;
        text-align: center;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }

      .summary-stats {
        margin-top: 12px;
        font-size: 14px;
        color: #5a5a5a;
        text-align: center;
        border-top: 1px solid #aaa;
        padding-top: 8px;
      }

      .summary-stats div {
        margin: 4px 0;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }

      .section-label {
        color: #2c5282;
        font-size: 16px;
        font-weight: bold;
        margin: 12px 0 6px 0;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }

      .summary-line-indent {
        margin: 6px 0;
        padding-left: 20px;
        display: flex;
        justify-content: space-between;
        font-size: 14px;
        color: #2c5282;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }

      .summary-spacer {
        height: 8px;
      }

      .summary-major-divider {
        height: 3px;
        background: linear-gradient(90deg, transparent, #666, transparent);
        margin: 12px 0;
        border-radius: 2px;
      }

      /* Bottom-left Leaderboard Box - Toy Story chrome style */
      #leaderboardBox {
        position: fixed;
        bottom: 25px;
        left: 2%;
        background: linear-gradient(145deg, #e8e8e8 0%, #c0c0c0 25%, #d4d4d4 50%, #a8a8a8 75%, #bcbcbc 100%);
        border: 3px solid #666;
        border-radius: 15px;
        padding: 16px 20px;
        box-shadow: 
          inset 0 4px 8px rgba(255, 255, 255, 0.6),
          inset 0 -2px 4px rgba(0, 0, 0, 0.3),
          0 4px 12px rgba(0, 0, 0, 0.4),
          0 2px 6px rgba(0, 0, 0, 0.2);
        font-family: 'Comic Sans MS', 'Arial Black', sans-serif;
        z-index: 30;
        width: max(300px, 33.3vw);
      }

      .leaderboard-header {
        color: #2c5282;
        font-size: 16px;
        font-weight: bold;
        text-align: center;
        margin-bottom: 12px;
        text-shadow: 0 2px 4px rgba(255, 255, 255, 0.8);
        border-bottom: 2px solid #999;
        padding-bottom: 6px;
      }

      #leaderboardBox #leaderboardList {
        margin-top: 10px;
        max-height: 300px;
        overflow-y: auto;
      }

      #leaderboardBox .leaderboard-entry {
        background: rgba(255, 255, 255, 0.3);
        padding: 8px 12px;
        margin: 6px 0;
        border-radius: 8px;
        border-left: 4px solid #ffd700;
        font-size: 12px;
        color: #2c5282;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }

      /* Toy Story Rocket Button */
      #startButton {
        margin-top: 20px;
        padding: 18px 40px;
        font-family: 'Comic Sans MS', 'Arial Black', sans-serif;
        font-size: clamp(18px, 3vw, 26px);
        font-weight: bold;
        color: white;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.6);
        border: none;
        border-radius: 25px;
        cursor: pointer !important; /* Override global cursor: none */
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
        
        /* Rocket-style gradient - red to orange like Toy Story rockets */
        background: linear-gradient(145deg, 
          #ff4757 0%, 
          #ff6b7a 15%, 
          #ff3742 30%, 
          #ff6348 50%, 
          #ff4757 70%, 
          #e55039 85%, 
          #c44569 100%);
        
        /* Multiple shadows for depth */
        box-shadow: 
          0 8px 16px rgba(255, 71, 87, 0.4),
          0 4px 8px rgba(0, 0, 0, 0.3),
          inset 0 2px 4px rgba(255, 255, 255, 0.3),
          inset 0 -2px 4px rgba(0, 0, 0, 0.2);
      }



      @keyframes rocket-pulse {
        0%, 100% { transform: translateY(-50%) scale(1); }
        50% { transform: translateY(-50%) scale(1.1); }
      }

      @keyframes rocket-mega-pulse {
        0%, 100% { transform: scale(1) rotate(-2deg); }
        25% { transform: scale(1.15) rotate(1deg); }
        50% { transform: scale(1.25) rotate(-1deg); }
        75% { transform: scale(1.1) rotate(2deg); }
      }



      #startButton:hover {
        background: linear-gradient(145deg, 
          #ff6b7a 0%, 
          #ff8a9b 15%, 
          #ff5252 30%, 
          #ff7979 50%, 
          #ff6b7a 70%, 
          #fd79a8 85%, 
          #e84393 100%);
        transform: translateY(-3px) scale(1.05);
        box-shadow: 
          0 12px 24px rgba(255, 71, 87, 0.5),
          0 6px 12px rgba(0, 0, 0, 0.4),
          inset 0 2px 4px rgba(255, 255, 255, 0.4),
          inset 0 -2px 4px rgba(0, 0, 0, 0.2);
      }

      #startButton:active {
        transform: translateY(-1px) scale(1.02);
        box-shadow: 
          0 6px 12px rgba(255, 71, 87, 0.4),
          0 3px 6px rgba(0, 0, 0, 0.3),
          inset 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      /* Enhanced Rocket Overlay */
      #rocketOverlay {
        position: absolute;
        left: -60px; /* Move even further left to clear "Launch" text */
        top: 50%;
        transform: translateY(-50%);
        z-index: 10;
        pointer-events: none; /* Allow clicks to pass through to button */
      }

      #rocketIcon {
        font-size: 3em; /* Much larger than current 1.2em */
        animation: rocket-mega-pulse 2s infinite ease-in-out;
        filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
      }



      #leaderboardList {
        margin-top: 10px;
      }

      .leaderboard-entry {
        background: rgba(255, 255, 255, 0.1);
        padding: 8px 12px;
        margin: 5px 0;
        border-radius: 8px;
        border-left: 4px solid #ffd700;
      }

      .leaderboard-entry:nth-child(1) {
        border-left-color: #ffd700;
      }
      .leaderboard-entry:nth-child(2) {
        border-left-color: #c0c0c0;
      }
      .leaderboard-entry:nth-child(3) {
        border-left-color: #cd7f32;
      }

      /* FULL-WIDTH SLOT MACHINE DISPLAY */
      #slotMachineDisplay {
        width: 100%;
        height: 100%;
        background: linear-gradient(145deg, #e6e6e6 0%, #cccccc 25%, #b3b3b3 50%, #999999 75%, #808080 100%);
        border-bottom: 4px solid #666666;
        box-shadow: 
          inset 0 2px 4px rgba(255, 255, 255, 0.8),
          inset 0 -2px 4px rgba(0, 0, 0, 0.3),
          0 2px 8px rgba(0, 0, 0, 0.4);
        position: relative;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        perspective: 1000px;
      }

      /* Rolling Numbers Container */
      #scoreDigits {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 6px;
        height: 80px;
        flex: 1;
      }

      /* Simplified Digit Container */
      .digit-container {
        width: 60px;
        height: 80px;
        position: relative;
      }

      /* The visible window showing the digit */
      .digit-window {
        width: 100%;
        height: 100%;
        background: linear-gradient(145deg, #1a1a1a 0%, #000000 50%, #1a1a1a 100%);
        border: 3px solid #666;
        border-radius: 8px;
        overflow: hidden;
        position: relative;
        box-shadow: 
          inset 0 4px 8px rgba(0, 0, 0, 0.8),
          inset 0 -2px 4px rgba(255, 255, 255, 0.2),
          0 2px 6px rgba(0, 0, 0, 0.4);
      }

      /* The spinning wheel strip */
      .digit-wheel {
        position: absolute;
        width: 100%;
        height: 800px; /* 10 digits × 80px each */
        top: 0;
        left: 0;
        transition: transform 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }

      /* Individual digit in the wheel */
      .digit-number {
        position: absolute;
        width: 100%;
        height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 36px;
        font-weight: bold;
        color: #00ff00;
        text-shadow: 0 0 8px #00ff00, 0 0 16px #00ff00;
        font-family: 'Courier New', monospace;
      }

      /* Position each digit in the wheel */
      .digit-number:nth-child(1) { top: 0px; }      /* 0 */
      .digit-number:nth-child(2) { top: 80px; }     /* 1 */
      .digit-number:nth-child(3) { top: 160px; }    /* 2 */
      .digit-number:nth-child(4) { top: 240px; }    /* 3 */
      .digit-number:nth-child(5) { top: 320px; }    /* 4 */
      .digit-number:nth-child(6) { top: 400px; }    /* 5 */
      .digit-number:nth-child(7) { top: 480px; }    /* 6 */
      .digit-number:nth-child(8) { top: 560px; }    /* 7 */
      .digit-number:nth-child(9) { top: 640px; }    /* 8 */
      .digit-number:nth-child(10) { top: 720px; }   /* 9 */

      /* Comma Separators */
      .comma-separator {
        width: 20px;
        height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 40px;
        color: #888;
        font-weight: bold;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      }

      #slotMachineDisplay::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8), transparent);
        animation: machine-shine 3s infinite;
      }

      @keyframes machine-shine {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
      }

      /* Rolling Numbers Container - merged above */

      /* Countdown Timer in Top Scoreboard */
      /* Current Level Display in Top Scoreboard */
      #topLevelDisplay {
        position: absolute;
        left: 20px;
        top: 50%;
        transform: translateY(-50%);
        background: linear-gradient(145deg, #1a1a1a 0%, #000000 50%, #1a1a1a 100%);
        border: 3px solid #666;
        border-radius: 12px;
        padding: 15px 25px;
        box-shadow: 
          inset 0 4px 8px rgba(0, 0, 0, 0.8),
          inset 0 -2px 4px rgba(255, 255, 255, 0.2),
          0 2px 6px rgba(0, 0, 0, 0.4);
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-align: center;
        z-index: 25;
        display: flex;
        align-items: baseline;
        gap: 8px;
        min-width: 120px;
      }
      
      .level-text {
        font-size: 20px;
        color: #cccccc;
        text-shadow: 0 0 6px #cccccc;
      }
      
      .level-number {
        font-size: 36px;
        color: #00aaff;
        text-shadow: 0 0 10px #00aaff, 0 0 20px #00aaff;
      }

      #topTimer {
        position: absolute;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        background: linear-gradient(145deg, #1a1a1a 0%, #000000 50%, #1a1a1a 100%);
        border: 3px solid #666;
        border-radius: 12px;
        padding: 15px 25px;
        box-shadow: 
          inset 0 4px 8px rgba(0, 0, 0, 0.8),
          inset 0 -2px 4px rgba(255, 255, 255, 0.2),
          0 2px 6px rgba(0, 0, 0, 0.4);
        font-family: 'Courier New', monospace;
        font-weight: bold;
        font-size: 36px;
        color: #00ff00;
        text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
        min-width: 80px;
        text-align: center;
        z-index: 25;
      }

      /* Timer warning states */
      #topTimer.warning {
        color: #ffaa00;
        text-shadow: 0 0 10px #ffaa00, 0 0 20px #ffaa00;
        animation: timer-pulse 1s infinite;
      }

      #topTimer.critical {
        color: #ff0000;
        text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
        animation: timer-pulse 0.5s infinite;
      }

      @keyframes timer-pulse {
        0%, 100% { transform: translateY(-50%) scale(1); }
        50% { transform: translateY(-50%) scale(1.05); }
      }

      /* Simplified Digit Container */
      .digit-container {
        width: 60px;
        height: 80px;
        position: relative;
      }

      /* The visible window showing the digit */
      .digit-window {
        width: 100%;
        height: 100%;
        background: linear-gradient(145deg, #1a1a1a 0%, #000000 50%, #1a1a1a 100%);
        border: 3px solid #666;
        border-radius: 8px;
        overflow: hidden;
        position: relative;
        box-shadow: 
          inset 0 4px 8px rgba(0, 0, 0, 0.8),
          inset 0 -2px 4px rgba(255, 255, 255, 0.2),
          0 2px 6px rgba(0, 0, 0, 0.4);
      }

      /* The spinning wheel strip */
      .digit-wheel {
        position: absolute;
        width: 100%;
        height: 800px; /* 10 digits × 80px each */
        top: 0;
        left: 0;
        transition: transform 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }

      /* Individual digit in the wheel */
      .digit-number {
        position: absolute;
        width: 100%;
        height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        font-size: 52px;
        color: #00ff00;
        text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
        background: linear-gradient(180deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%);
        border-top: 1px solid rgba(0, 255, 0, 0.2);
        border-bottom: 1px solid rgba(0, 255, 0, 0.1);
      }

      /* Position digits vertically in the wheel */
      .digit-number:nth-child(1) { top: 0px; }     /* 0 */
      .digit-number:nth-child(2) { top: 80px; }    /* 1 */
      .digit-number:nth-child(3) { top: 160px; }   /* 2 */
      .digit-number:nth-child(4) { top: 240px; }   /* 3 */
      .digit-number:nth-child(5) { top: 320px; }   /* 4 */
      .digit-number:nth-child(6) { top: 400px; }   /* 5 */
      .digit-number:nth-child(7) { top: 480px; }   /* 6 */
      .digit-number:nth-child(8) { top: 560px; }   /* 7 */
      .digit-number:nth-child(9) { top: 640px; }   /* 8 */
      .digit-number:nth-child(10) { top: 720px; }  /* 9 */

      /* Comma Separators */
      .comma-separator {
        width: 20px;
        height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 40px;
        color: #888;
        font-weight: bold;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      }

      /* Splash Screen Logo */
      #splashLogo {
        position: fixed;
        width: 33.3vw;
        height: auto;
        left: 2%;
        top: 11%;
        z-index: 15;
        pointer-events: none;
        display: none;
      }

      /* Victory Celebration Keyframe Animations - Transform Only */
      @keyframes logo-to-center-transform {
        0% {
          transform: translate(0, 0) scale(1);
        }
        100% {
          /* Move from 2% left to 50% centered: 48% right + center the 33.3vw width */
          /* Move from 11% top to 50% centered: 25% down + center vertically */
          transform: translate(calc(48vw - 16.65vw), 25vh) scale(2);
        }
      }

      @keyframes logo-spin-smooth {
        0% {
          transform: translate(calc(48vw - 16.65vw), 25vh) scale(2) rotate(0deg);
        }
        100% {
          /* 5 full rotations = 1800 degrees */
          transform: translate(calc(48vw - 16.65vw), 25vh) scale(2) rotate(1800deg);
        }
      }

      @keyframes logo-return-home-transform {
        0% {
          transform: translate(calc(48vw - 16.65vw), 25vh) scale(2);
        }
        100% {
          transform: translate(0, 0) scale(1);
        }
      }

    </style>
  </head>
  <body>
    <div id="mainContainer">
      <!-- Splash Screen Logo -->
      <img id="splashLogo" src="TSBalloonie-logo.png" alt="TSBalloonie Logo">
      
      <!-- Top Scoreboard Area -->
      <div id="scoreboardArea">
        <div id="slotMachineDisplay">
          <div id="topLevelDisplay">
            <span class="level-text">Level</span>
            <span class="level-number">1</span>
          </div>
          <div id="scoreDigits">0</div>
          <div id="topTimer">20</div>
        </div>
      </div>
      
      <!-- Chrome Separator -->
      <div id="chromeSeparator"></div>
      
      <!-- Game Area -->
      <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
      </div>
      
      <!-- Custom Cursor - Global positioning -->
      <div id="customCursor">
        <div class="cursor-pointer"></div>
      </div>
      <div id="levelStart">
        <button id="startButton" onclick="startLevel()">Launch Next Level ➤</button>
        <div id="rocketOverlay">
          <div id="rocketIcon">🚀</div>
        </div>
      </div>
      
      <!-- Sound mode box in bottom right area -->
      <div id="soundModeBox">
        <div class="sound-mode-label">Game Sound</div>
        <div class="toggle-container">
          <div class="toggle-track">
            <div class="toggle-slider quiet" id="soundToggleSlider"></div>
          </div>
          <div class="toggle-labels">
            <span class="quiet-label">OFF</span>
            <span class="noisy-label">ON</span>
          </div>
        </div>
      </div>
      
      <!-- Info box in bottom right corner -->
      <div id="splashInfoBox">
        <div class="skill-level-label">Skill level</div>
        <div class="difficulty-selection">
          <label class="radio-option rex">
            <input type="radio" name="difficulty" value="rex" />
            <span>Rex</span>
          </label>
          <label class="radio-option woody">
            <input type="radio" name="difficulty" value="woody" checked />
            <span>Woody</span>
          </label>
          <label class="radio-option buzz">
            <input type="radio" name="difficulty" value="buzz" />
            <span>Buzz</span>
          </label>
        </div>
        <div class="info-text" id="cheatInfoText">ALT-P(op) for cheat</div>
        <button class="about-btn" onclick="showAboutDialog()">ABOUT</button>
      </div>
      <div id="gameOver">
        <div id="gameOverText"></div>
        <button class="restart-btn" onclick="resetGame()">Play Again</button>
      </div>

      <!-- Game Summary Box -->
      <div id="gameSummary" style="display: none;">
        <div class="summary-header">
          <div class="summary-header-line">
            <span id="summaryHeaderText">LEVEL CLEARED!</span>
            <span id="summaryLevelNumber">1</span>
          </div>
        </div>
        <div class="summary-content">
          <div class="section-label">Level Stats:</div>
          <div class="summary-line-indent">Balloon Points: <span id="summaryBalloonPoints">0</span></div>
          <div class="summary-line-indent">Streak Bonus: <span id="summaryStreakPoints">0</span></div>
          <div class="summary-line-indent">Numbered Balloon bonus: <span id="summarySequencePoints">0</span></div>
          <div class="summary-divider"></div>
          <div class="summary-total">Total Level Score: <span id="summaryTotalPoints">0</span></div>
          
          <div class="summary-spacer"></div>
          <div class="summary-line">Level Time: <span id="summaryTime">0s</span></div>
          <div class="summary-line">Level Balloons popped: <span id="summaryLevelBalloons">0</span></div>
          <div class="summary-line">Current popping streak: <span id="summaryStreak">0</span></div>
          
          <div class="summary-major-divider"></div>
          
          <div class="summary-prior-score">(Prior score: <span id="summaryPriorScore">0</span>)</div>
          <div class="summary-game-score">Game Score: <span id="summaryGameScore">0</span></div>
          <div class="summary-line">Game Time: <span id="summaryGameTime">0s</span></div>
          <div class="summary-line">Game Balloons popped: <span id="summaryGameBalloons">0</span></div>
          <div class="summary-line">Game longest popping streak: <span id="summaryLongestStreak">0</span></div>
        </div>
      </div>

      <!-- Bottom-left Leaderboard Box -->
      <div id="leaderboardBox" style="display: none;">
        <div class="leaderboard-header">Top 5 Games</div>
        <div id="leaderboardList">
          <div style="color: #888;">No games completed yet</div>
        </div>
        <div style="text-align: center; margin-top: 15px;">
          <button onclick="hideLeaderboard()" class="start-button" style="margin-right: 10px;">
            Continue
          </button>
          <button onclick="resetHighScores()" class="start-button">
            Reset Scores
          </button>
        </div>
      </div>

    </div>

    <!-- Amiga System Error Style About Dialog -->
    <div id="aboutDialog" class="amiga-dialog" style="display: none;">
      <div class="amiga-dialog-content">
        <div class="amiga-title-bar">
          <span class="amiga-title">Powered by Amiga</span>
        </div>
        <div class="amiga-dialog-body">
          <div class="amiga-icon">⚠</div>
          <div class="amiga-text">TS Balloonie - simple ballon popink game<br>
            &nbsp;<br>
            Hit numbert balls in sequance for big pointz!<br>
            Don't miss! Consecutif ballon pops add pointz!<br>
            &nbsp;<br>
            Choose skill level viseli<br>
            &nbsp;<br>
            Codet entireli by Poppy (Claude Code) - no human editink at all<br>
            Promptink vas a bi*ch<br>
            &nbsp;<br>
            Assets createt by chatzy (ChapGPT 5)<br>
            apologiks to John L/Disnei<br>
            &nbsp;<br>
            Desikn by John<br>
            for my sweetie<br>
            &nbsp;<br>
            0.19.1 Seattle, WA August 22, 2025</div>
        </div>
        <div class="amiga-button-bar">
          <button class="amiga-button" onclick="hideAboutDialog()">CLOSE</button>
        </div>
      </div>
    </div>

    <script>
      // Game variables
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const topTimerElement = document.getElementById("topTimer");
      const topLevelDisplay = document.getElementById("topLevelDisplay");
      const levelNumberElement = document.querySelector(".level-number");
      
      // Game summary elements
      const gameSummaryElement = document.getElementById("gameSummary");
      const summaryHeaderText = document.getElementById("summaryHeaderText");
      const summaryLevelNumber = document.getElementById("summaryLevelNumber");
      const summaryBalloonPoints = document.getElementById("summaryBalloonPoints");
      const summaryStreakPoints = document.getElementById("summaryStreakPoints");
      const summarySequencePoints = document.getElementById("summarySequencePoints");
      const summaryTotalPoints = document.getElementById("summaryTotalPoints");
      const summaryTime = document.getElementById("summaryTime");
      const summaryStreak = document.getElementById("summaryStreak");
      const summaryPriorScore = document.getElementById("summaryPriorScore");
      const summaryGameScore = document.getElementById("summaryGameScore");
      const summaryLevelBalloons = document.getElementById("summaryLevelBalloons");
      const summaryGameTime = document.getElementById("summaryGameTime");
      const summaryGameBalloons = document.getElementById("summaryGameBalloons");
      const summaryLongestStreak = document.getElementById("summaryLongestStreak");
      const gameOverElement = document.getElementById("gameOver");
      const gameOverText = document.getElementById("gameOverText");
      const levelStartElement = document.getElementById("levelStart");
      const startButton = document.getElementById("startButton");
      
      // Slot machine display elements
      const scoreDigitsElement = document.getElementById("scoreDigits");
      const customCursor = document.getElementById("customCursor");
      const mainContainer = document.getElementById("mainContainer");

      let gameRunning = false;
      let gameTime = 20;
      let balloons = [];
      let stars = [];
      let animationId;
      let gameTimer;
      let balloonSpeed = 1.5; // Default speed (5.0 is max)
      let currentLevel = 1;
      let cumulativeTime = 0;
      let levelStartTime = 0;
      let levelEndsAt = 0; // performance.now timestamp
      let waitingForStart = true;
      let cheaterFlag = false; // Track if cheat has been used

      // Background image system
      let availableBackgrounds = [];
      let currentBackground = null;

      // Sequence bonus system
      let sequenceProgress = 0; // Next number in sequence we're looking for (0 means sequence not started)
      let maxSequenceNumber = 0; // Highest number assigned to balloons in current level
      let sequenceBroken = false; // Flag to track if sequence has been permanently broken

      // Level scoring breakdown tracking
      let levelBalloonPoints = 0; // Points from just popping balloons
      let levelStreakPoints = 0; // Points from streak bonuses
      let levelSequencePoints = 0; // Points from sequence bonuses

      // Game-level statistics tracking
      let gameBalloonsPopped = 0; // Total balloons popped across all levels
      let longestStreak = 0; // Longest streak achieved during the entire game
      let gameStartTime = 0; // Start time of the entire game
      let splashBackground = null;
      let currentLevelBackground = null; // Track background for current level
      let usingStarfieldFallback = true; // Start with starfield until background loads

      // DPR variables
      let dpr = 1;
      function cssWidth() { return canvas.width / dpr; }
      function cssHeight() { return canvas.height / dpr; }

      // Game statistics
      let totalBalloonsPopped = 0;
      let currentGameBalloons = 0;

      // New scoring system variables
      let currentScore = 0;
      let consecutiveHits = 0;
      let currentStreakList = []; // List of completed streaks (5+) for current game
      let totalStreaks = 0; // Total number of 5+ streaks achieved across all games
      
      // Slot machine system variables
      let digitContainers = [];
      let previousScore = 0;
      
      // ============================================================================
      // URL PARAMETER DEBUGGING SYSTEM
      // ============================================================================
      
      // Parse URL parameters for debugging
      function parseUrlParams() {
        const urlParams = new URLSearchParams(window.location.search);
        const params = {};
        
        // Parse level parameter
        const levelParam = urlParams.get('level');
        if (levelParam !== null) {
          const level = parseInt(levelParam, 10);
          if (!isNaN(level) && level >= 1 && level <= 10) {
            params.level = level;
          } else {
            console.warn(`Invalid level parameter: ${levelParam}. Must be integer between 1-10. Using default level 1.`);
          }
        }
        
        // Parse score parameter
        const scoreParam = urlParams.get('score');
        if (scoreParam !== null) {
          const score = parseInt(scoreParam, 10);
          if (!isNaN(score) && score >= 0 && score <= Number.MAX_SAFE_INTEGER) {
            params.score = score;
          } else {
            console.warn(`Invalid score parameter: ${scoreParam}. Must be non-negative integer. Using default score 0.`);
          }
        }
        
        return params;
      }
      
      // Apply debug parameters if present in URL
      function applyDebugParams() {
        const params = parseUrlParams();
        let debugApplied = false;
        
        console.log('🔧 Debug Parameter Check:');
        console.log(`URL: ${window.location.href}`);
        
        // Apply level parameter
        if (params.level !== undefined) {
          const originalLevel = currentLevel;
          currentLevel = params.level;
          debugApplied = true;
          console.log(`✅ Debug Level Applied: ${originalLevel} → ${currentLevel}`);
        } else {
          console.log(`ℹ️  Level: ${currentLevel} (default)`);
        }
        
        // Apply score parameter
        if (params.score !== undefined) {
          const originalScore = currentScore;
          currentScore = params.score;
          previousScore = params.score; // Set previous score to match for proper display
          debugApplied = true;
          console.log(`✅ Debug Score Applied: ${originalScore.toLocaleString()} → ${currentScore.toLocaleString()}`);
        } else {
          console.log(`ℹ️  Score: ${currentScore.toLocaleString()} (default)`);
        }
        
        if (debugApplied) {
          console.log('🎮 Debug parameters have been applied! Game will start with custom values.');
          console.log('💡 Usage: Add ?level=X&score=Y to URL (e.g., TSBalloonie.html?level=5&score=1000000)');
        } else {
          console.log('🎮 No debug parameters found. Starting with default values.');
          console.log('💡 To use debug mode, add ?level=X&score=Y to URL (e.g., TSBalloonie.html?level=5&score=1000000)');
        }
        
        return debugApplied;
      }

      // Canvas resizing with DPR scaling
      function resizeCanvas() {
        const container = document.getElementById("gameContainer");
        const rect = container.getBoundingClientRect();

        dpr = Math.max(1, window.devicePixelRatio || 1);
        const cssW = Math.max(0, rect.width - 6);
        const cssH = Math.max(0, rect.height - 6);

        // Set CSS size
        canvas.style.width = cssW + "px";
        canvas.style.height = cssH + "px";

        // Backing store in device pixels
        canvas.width = Math.floor(cssW * dpr);
        canvas.height = Math.floor(cssH * dpr);

        // Scale the context so drawing uses CSS-pixel coordinates
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        // Keep balloons within new bounds (in CSS px)
        balloons.forEach(b => {
          const w = cssWidth(), h = cssHeight();
          if (b.x + b.radius > w) b.x = w - b.radius;
          if (b.y + b.radius > h) b.y = h - b.radius;
        });
      }

      // Background image discovery and management
      async function discoverBackgroundImages() {
        console.log('Starting dynamic background image discovery...');
        
        // Test for background files using pattern BG-1.png through BG-20.png
        const discovered = [];
        const testPromises = [];
        
        // Create promises to test each potential background file
        for (let i = 1; i <= 20; i++) {
          const filename = `BG-${i}.png`;
          
          const testPromise = new Promise((resolve) => {
            const img = new Image();
            
            img.onload = function() {
              console.log(`✓ Found background: ${filename}`);
              resolve(filename);
            };
            
            img.onerror = function() {
              console.log(`✗ Missing background: ${filename}`);
              resolve(null);
            };
            
            // Start loading test
            img.src = filename;
          });
          
          testPromises.push(testPromise);
        }
        
        // Wait for all tests to complete
        console.log('Testing for background files BG-1.png through BG-20.png...');
        const results = await Promise.all(testPromises);
        
        // Filter out null results (files that didn't exist)
        const foundFiles = results.filter(filename => filename !== null);
        availableBackgrounds = foundFiles;
        
        console.log(`Discovery complete! Found ${availableBackgrounds.length} background files:`, availableBackgrounds);
        
        if (availableBackgrounds.length === 0) {
          console.log('No background images found, starfield will be used');
          usingStarfieldFallback = true;
        } else {
          console.log('Background images available, starfield will be hidden when images load');
        }
        
        // For now, no specific splash image - will use random background
        splashBackground = null;
        console.log('No specific splash image configured, will use random background');
      }
      
      function selectRandomBackground() {
        if (availableBackgrounds.length === 0) {
          usingStarfieldFallback = true;
          return null;
        }
        
        const randomIndex = Math.floor(Math.random() * availableBackgrounds.length);
        return availableBackgrounds[randomIndex];
      }
      
      function applyBackgroundImage(imagePath, fallbackToStarfield = true) {
        if (!imagePath) {
          // Clear background and use starfield
          mainContainer.style.backgroundImage = '';
          mainContainer.style.backgroundColor = '#001122';
          usingStarfieldFallback = true;
          console.log('No background image provided, using starfield fallback');
          return;
        }
        
        // Create a new image to test loading
        const img = new Image();
        
        img.onload = function() {
          mainContainer.style.backgroundImage = `url('${imagePath}')`;
          currentBackground = imagePath;
          usingStarfieldFallback = false;
          console.log('Background successfully applied:', imagePath);
        };
        
        img.onerror = function() {
          console.warn('Failed to load background image:', imagePath);
          if (fallbackToStarfield) {
            mainContainer.style.backgroundImage = '';
            mainContainer.style.backgroundColor = '#001122';
            usingStarfieldFallback = true;
            console.log('Background loading failed, using starfield fallback');
          }
        };
        
        console.log('Attempting to load background image:', imagePath);
        img.src = imagePath;
      }
      
      function setRandomBackground() {
        const selectedBackground = selectRandomBackground();
        console.log('Setting random background:', selectedBackground || 'none (using starfield)');
        applyBackgroundImage(selectedBackground);
      }
      
      function setSplashBackground() {
        if (splashBackground) {
          console.log('Setting splash background:', splashBackground);
          applyBackgroundImage(splashBackground);
        } else {
          // Use a random background for splash if no specific splash image
          console.log('No splash background found, using random background');
          setRandomBackground();
        }
      }
      
      function setFixedSplashBackground() {
        console.log('Setting fixed splash background: TSBalloonie-background.png');
        applyBackgroundImage('TSBalloonie-background.png');
      }

      // Level system functions
      function getLevelBalloonCount(level) {
        // Level 1: 10 balloons, Level 10: 20 balloons
        return Math.floor(10 + ((level - 1) * (20 - 10)) / 9);
      }

      function getLevelBalloonSize(level) {
        // Keep balloon sizes consistent across all levels (easy-medium difficulty)
        // Use Level 1 size for all levels: medium-large balloons
        const baseMinRadius = 40; // Consistent size
        const baseMaxRadius = 60; // Consistent size

        // Apply size variation (0.75x to 1.25x) and then increase by 50%
        const minRadius = Math.floor(baseMinRadius * 0.75 * 1.5); // 50% larger
        const maxRadius = Math.floor(baseMaxRadius * 1.25 * 1.5); // 50% larger

        return { min: minRadius, max: maxRadius };
      }

      function getLevelSpeed(level, baseSpeed) {
        // Gentler progression: Level 1 = 1.5, Level 10 = 3.0 (was 5.0)
        // This makes Level 10 about the same speed as old Level 5
        const levelMultiplier = 1.5 + ((level - 1) * (3.0 - 1.5)) / 9; // 1.5 to 3.0 over 9 steps
        return (baseSpeed / 1.5) * levelMultiplier; // Adjust based on slider position
      }

      function getDifficultyTime() {
        const selectedDifficulty = document.querySelector('input[name="difficulty"]:checked');
        if (!selectedDifficulty) return 20; // Default fallback
        
        switch(selectedDifficulty.value) {
          case 'rex': return 20;    // Easy - 20 seconds
          case 'woody': return 15;  // Medium - 15 seconds  
          case 'buzz': return 10;   // Hard - 10 seconds
          default: return 20;
        }
      }

      function setupDifficultySelection() {
        console.log('🎛️ Setting up difficulty selection...');
        const difficultyRadios = document.querySelectorAll('input[name="difficulty"]');
        const difficultyLabels = document.querySelectorAll('.radio-option');
        
        console.log(`📻 Found ${difficultyRadios.length} radio inputs and ${difficultyLabels.length} labels`);
        
        // Log initial states
        difficultyRadios.forEach(radio => {
          console.log(`📻 Initial state: ${radio.value} = ${radio.checked ? 'CHECKED' : 'unchecked'}`);
        });
        
        // Add comprehensive mouse event debugging
        difficultyLabels.forEach(label => {
          const radioValue = label.querySelector('input').value;
          
          // Click event
          label.addEventListener('click', function(event) {
            console.log(`🖱️ Label CLICKED: ${radioValue} (target: ${event.target.tagName}, currentTarget: ${event.currentTarget.className})`);
            console.log(`   Event details: bubbles=${event.bubbles}, cancelable=${event.cancelable}, defaultPrevented=${event.defaultPrevented}`);
            
            // Check if click reached the input
            const input = this.querySelector('input');
            setTimeout(() => {
              console.log(`   Input state after click: checked=${input.checked}`);
            }, 50);
          });
          
          // Mouse events for debugging
          label.addEventListener('mousedown', (e) => console.log(`🖱️ MouseDOWN: ${radioValue}`));
          label.addEventListener('mouseup', (e) => console.log(`🖱️ MouseUP: ${radioValue}`));
          label.addEventListener('mouseenter', (e) => console.log(`🖱️ MouseENTER: ${radioValue}`));
          label.addEventListener('mouseleave', (e) => console.log(`🖱️ MouseLEAVE: ${radioValue}`));
          
          // Add event debugging to the input itself  
          const input = label.querySelector('input');
          input.addEventListener('click', function(event) {
            console.log(`📻 Input CLICKED directly: ${this.value} (checked will be: ${!this.checked})`);
          });
        });
        
        difficultyRadios.forEach(radio => {
          console.log(`🔗 Adding change listener to: ${radio.value}`);
          radio.addEventListener('change', function() {
            console.log(`📻 Radio change event: ${this.value} -> checked: ${this.checked}`);
            
            if (this.checked) {
              // Log all current states
              const allStates = [];
              difficultyRadios.forEach(r => allStates.push(`${r.value}=${r.checked}`));
              console.log(`✅ All radio states after change: ${allStates.join(', ')}`);
              
              switch(this.value) {
                case 'rex':
                  balloonSpeed = 1.3; // Easy
                  break;
                case 'woody':
                  balloonSpeed = 1.5; // Medium
                  break;
                case 'buzz':
                  balloonSpeed = 2.0; // Hard
                  break;
              }
              
              console.log(`⚙️ Balloon speed updated to ${balloonSpeed} for difficulty: ${this.value}`);
              
              // Update game time based on difficulty
              const newGameTime = getDifficultyTime();
              if (gameRunning && newGameTime !== gameTime) {
                // Update time for current game - adjust levelEndsAt to reflect new time limit
                const timeElapsed = performance.now() - (levelEndsAt - gameTime * 1000);
                gameTime = newGameTime;
                levelEndsAt = performance.now() + (gameTime * 1000) - timeElapsed;
                console.log(`⏰ Game time updated to ${gameTime} seconds for difficulty: ${this.value}`);
              } else {
                gameTime = newGameTime;
                console.log(`⏰ Game time set to ${gameTime} seconds for difficulty: ${this.value}`);
              }
              
              // Update timer display immediately to show new time limit
              updateTopTimer();
              
              // Update existing balloon speeds if game is running
              if (gameRunning) {
                balloons.forEach((balloon) => {
                  if (!balloon.popping) {
                    const currentSpeed = Math.sqrt(
                      balloon.vx * balloon.vx + balloon.vy * balloon.vy
                    );
                    if (currentSpeed > 0) {
                      // Recalculate this balloon's individual speed with new base speed
                      const newBaseSpeed = getLevelSpeed(currentLevel, balloonSpeed);
                      const speedRatio =
                        balloon.individualSpeed / getLevelSpeed(currentLevel, 1.5); // Original ratio
                      balloon.individualSpeed = newBaseSpeed * speedRatio;

                      // Update velocity to match new individual speed
                      const ratio = balloon.individualSpeed / currentSpeed;
                      balloon.vx *= ratio;
                      balloon.vy *= ratio;
                    }
                  }
                });
              }
            } else {
              console.log(`❌ Radio ${this.value} fired change event but not checked`);
            }
          });
        });
        
        // Add state verification function
        window.debugRadioStates = function() {
          console.log('🔍 Manual radio state check:');
          difficultyRadios.forEach(radio => {
            const label = document.querySelector(`.radio-option.${radio.value}`);
            const hasSelectedClass = label ? label.matches(':has(input:checked)') : false;
            console.log(`📻 ${radio.value}: input.checked=${radio.checked}, hasSelectedCSS=${hasSelectedClass}`);
          });
          console.log(`⚙️ Current balloon speed: ${balloonSpeed}`);
        };
        
        console.log('✅ Difficulty selection setup complete. Type debugRadioStates() to check states manually.');
        
        // Optional: Add periodic state checking (uncomment to enable)
        window.startRadioDebugMonitor = function() {
          if (window.radioDebugInterval) clearInterval(window.radioDebugInterval);
          console.log('🔄 Starting radio button monitor (every 5 seconds)...');
          window.radioDebugInterval = setInterval(() => {
            const checkedRadios = Array.from(difficultyRadios).filter(r => r.checked);
            if (checkedRadios.length !== 1) {
              console.warn(`⚠️ ISSUE: Expected 1 checked radio, found ${checkedRadios.length}:`, checkedRadios.map(r => r.value));
              debugRadioStates();
            }
          }, 5000);
        };
        
        window.stopRadioDebugMonitor = function() {
          if (window.radioDebugInterval) {
            clearInterval(window.radioDebugInterval);
            console.log('⏹️ Radio button monitor stopped');
          }
        };
        
        // Comprehensive diagnostic function
        window.debugSkillButtons = function() {
          console.log('🔧 === SKILL BUTTON DIAGNOSTIC ===');
          
          // 1. Check element visibility
          const splashBox = document.getElementById('splashInfoBox');
          console.log('📦 SplashInfoBox:');
          console.log(`   Display: ${splashBox.style.display}`);
          console.log(`   Computed display: ${getComputedStyle(splashBox).display}`);
          console.log(`   Visible: ${splashBox.offsetWidth > 0 && splashBox.offsetHeight > 0}`);
          console.log(`   Position: ${getComputedStyle(splashBox).position}`);
          console.log(`   Z-index: ${getComputedStyle(splashBox).zIndex}`);
          
          // 2. Check each button
          const buttons = document.querySelectorAll('.radio-option');
          console.log('🎛️ Button States:');
          buttons.forEach((btn, i) => {
            const input = btn.querySelector('input');
            const rect = btn.getBoundingClientRect();
            const style = getComputedStyle(btn);
            console.log(`   Button ${i} (${input.value}):`);
            console.log(`     Input checked: ${input.checked}`);
            console.log(`     Visible: ${rect.width > 0 && rect.height > 0}`);
            console.log(`     Position: (${rect.left}, ${rect.top}) ${rect.width}x${rect.height}`);
            console.log(`     Pointer events: ${style.pointerEvents}`);
            console.log(`     Z-index: ${style.zIndex}`);
          });
          
          // 3. Check for overlapping elements
          console.log('🔍 Checking for overlapping elements...');
          const buttonArea = buttons[0].parentElement.getBoundingClientRect();
          const elementsAtPoint = document.elementsFromPoint(
            buttonArea.left + buttonArea.width/2, 
            buttonArea.top + buttonArea.height/2
          );
          console.log('   Elements at button center point:', elementsAtPoint.map(el => 
            el.tagName + (el.id ? `#${el.id}` : '') + (el.className ? `.${el.className}` : '')
          ));
          
          // 4. Test click simulation
          console.log('🖱️ Simulating click on first button...');
          const firstButton = buttons[0];
          const clickEvent = new MouseEvent('click', {
            bubbles: true,
            cancelable: true,
            view: window
          });
          firstButton.dispatchEvent(clickEvent);
          
          console.log('🔧 === END DIAGNOSTIC ===');
        };
      }

      // Sound mode toggle functionality
      let soundMode = 'quiet'; // Default state
      let preloadedSounds = {}; // Store preloaded audio objects

      function preloadGameSounds() {
        console.log('🔊 Preloading game sounds...');
        const soundFiles = [
          { file: 'Buzz-01.mp3', volume: 0.7 },
          { file: 'Buzz-02.mp3', volume: 0.7 },
          { file: 'Buzz-03.mp3', volume: 0.7 },
          { file: 'Fanfare-01.mp3', volume: 0.8 }
        ];
        
        soundFiles.forEach(soundData => {
          try {
            const audio = new Audio(soundData.file);
            audio.volume = soundData.volume; // Set volume during preload
            audio.preload = 'auto'; // Ensure audio is preloaded
            preloadedSounds[soundData.file] = audio;
            console.log(`🔊 Preloaded: ${soundData.file} (volume: ${soundData.volume})`);
          } catch (e) {
            console.warn(`🔇 Failed to preload ${soundData.file}:`, e);
          }
        });
        
        console.log('✅ Game sound preloading complete');
      }

      function setupSoundToggle() {
        console.log('🔊 Setting up sound toggle...');
        
        // Preload sounds first
        preloadGameSounds();
        
        const toggleTrack = document.querySelector('.toggle-track');
        const toggleSlider = document.getElementById('soundToggleSlider');
        
        if (!toggleTrack || !toggleSlider) {
          console.warn('Sound toggle elements not found');
          return;
        }
        
        toggleTrack.addEventListener('click', function() {
          if (soundMode === 'quiet') {
            // Switch to NOISY
            soundMode = 'noisy';
            toggleSlider.className = 'toggle-slider noisy';
            console.log('🔊 Sound toggle switched to ON');
            
            // Play random buzz sound
            playBuzzSound();
            
            // After 1 second, jiggle and return to quiet
            setTimeout(() => {
              toggleSlider.classList.add('jiggle');
              setTimeout(() => {
                soundMode = 'quiet';
                toggleSlider.className = 'toggle-slider quiet';
                console.log('🔇 Sound toggle returned to OFF');
              }, 500); // Jiggle duration
            }, 1000);
            
          } else {
            // Already switching back, do nothing during transition
            console.log('🔊 Toggle busy - ignoring click during transition');
          }
        });
        
        console.log('✅ Sound toggle setup complete');
      }

      function playBuzzSound() {
        const soundFiles = ['Buzz-01.mp3', 'Buzz-02.mp3', 'Buzz-03.mp3']; // Add Buzz-03
        const randomSound = soundFiles[Math.floor(Math.random() * soundFiles.length)];
        
        try {
          // Use preloaded audio if available, otherwise create new
          const audio = preloadedSounds[randomSound] || new Audio(randomSound);
          
          // Reset to beginning in case it was played before
          audio.currentTime = 0;
          
          // Set volume if using fallback audio
          if (!preloadedSounds[randomSound]) {
            audio.volume = 0.7;
          }
          
          audio.play().then(() => {
            console.log(`🔊 Playing sound: ${randomSound}`);
          }).catch(e => {
            console.log('🔇 Sound play failed:', e);
          });
        } catch (e) {
          console.log('🔇 Sound creation failed:', e);
        }
      }

      function playVictoryFanfare() {
        console.log('🎺 Starting victory fanfare...');
        
        try {
          // Use preloaded fanfare audio
          const audio = preloadedSounds['Fanfare-01.mp3'];
          if (!audio) {
            console.warn('🎺 Fanfare-01.mp3 not preloaded, creating fallback');
            const fallbackAudio = new Audio('Fanfare-01.mp3');
            fallbackAudio.volume = 0.8;
            fallbackAudio.play().then(() => {
              console.log('🎺 Victory fanfare playing (fallback)');
            }).catch(e => {
              console.log('🔇 Victory fanfare failed (fallback):', e);
            });
            return;
          }
          
          // Reset to beginning in case it was played before
          audio.currentTime = 0;
          
          audio.play().then(() => {
            console.log('🎺 Victory fanfare playing!');
          }).catch(e => {
            console.log('🔇 Victory fanfare failed:', e);
          });
        } catch (e) {
          console.log('🔇 Victory fanfare creation failed:', e);
        }
      }

      // Amiga-style about dialog functions
      function showAboutDialog() {
        document.getElementById('aboutDialog').style.display = 'flex';
        console.log('🖥️ Amiga-style about dialog opened');
      }

      function hideAboutDialog() {
        document.getElementById('aboutDialog').style.display = 'none';
        console.log('🖥️ Amiga-style about dialog closed');
      }

      // Balloon class will be implemented next
      class Balloon {
        constructor(x, y, radius, color, number = null) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.color = color;
          this.number = number; // Sequential number for bonus scoring (null if no number)

          // Individual speed variation (0.75x to 1.25x of level speed)
          const baseSpeed = getLevelSpeed(currentLevel, balloonSpeed);
          const speedMultiplier = 0.75 + Math.random() * 0.5; // 0.75 to 1.25
          this.individualSpeed = baseSpeed * speedMultiplier;

          this.vx = (Math.random() - 0.5) * this.individualSpeed; // Random velocity x
          this.vy = (Math.random() - 0.5) * this.individualSpeed; // Random velocity y

          // String color (varied like real foil strings)
          const stringColors = [
            "#FFD700",
            "#C0C0C0",
            "#FF6B6B",
            "#4ECDC4",
            "#45B7D1",
            "#96CEB4",
            "#DDA0DD",
            "#F7DC6F",
          ];
          this.stringColor =
            stringColors[Math.floor(Math.random() * stringColors.length)];

          this.popping = false;
          this.popAnimation = 0;
        }
      }

      // Initialize the game
      async function init() {
        resizeCanvas();
        setupDifficultySelection();
        setupSoundToggle();
        loadStatistics();
        
        // Apply debug parameters from URL if present
        const debugApplied = applyDebugParams();

        // Discover available background images
        await discoverBackgroundImages();
        
        // Create starfield initially (will be hidden if backgrounds work)
        createStarField();
        
        // Set fixed splash screen background
        setFixedSplashBackground();
        
        // Initialize score display
        initializeScoreDisplay();
        
        // Setup cursor event listeners - make cursor visible globally
        document.addEventListener('mousemove', handleMouseMove);
        // Keep cursor always visible during game
        customCursor.style.opacity = '1';
        customCursor.style.display = 'block';
        
        // Set initial cursor position
        customCursor.style.left = '100px';
        customCursor.style.top = '100px';
        
        // Initial cursor update to set proper content
        updateCursor();
        
        // Setup keyboard cheat listener (ALT-P)
        document.addEventListener('keydown', (event) => {
          if (event.altKey && (event.key === 'p' || event.key === 'P')) {
            event.preventDefault(); // Prevent browser shortcuts
            cheatPopRandomBalloon();
          }
        });
        
        // Update all displays (including slot machine with any debug values)
        updateScoreDisplay();
        updateStreakDisplay();
        updateSlotMachineDisplay();
        updateCursor();
        updateTopTimer();
        updateTopLevel();
        
        if (debugApplied) {
          console.log('🔧 All displays updated with debug values');
        }
        
        // Log initialization complete and available features
        console.log('🎮 TSBalloonie initialized successfully!');
        console.log('💡 Available features:');
        console.log('  • Cheat Code: ALT-P during gameplay to pop random balloon');
        console.log('  • Debug Commands: Type debugHelp() in console for full list');
        console.log('  • URL Parameters: ?level=X&score=Y for testing');

        showLevelStart();

        // Add resize event listener
        window.addEventListener("resize", () => {
          resizeCanvas();
          // Recreate star field when canvas resizes
          if (usingStarfieldFallback) {
            createStarField();
          }
          // Adjust balloon positions if they're outside new boundaries
          balloons.forEach((balloon) => {
            if (balloon.x + balloon.radius > canvas.width) {
              balloon.x = canvas.width - balloon.radius;
            }
            if (balloon.y + balloon.radius > canvas.height) {
              balloon.y = canvas.height - balloon.radius;
            }
          });
        });
      }

      // Show level start screen
      function showLevelStart() {
        console.log(`🚀 showLevelStart() called for level ${currentLevel}`);
        waitingForStart = true;
        startButton.textContent = `Launch Level ${currentLevel} ➤`;
        levelStartElement.style.display = "block";
        
        const splashInfoBox = document.getElementById("splashInfoBox");
        splashInfoBox.style.display = "block"; // Show info box on splash screen
        
        // Show sound mode box on splash screen
        document.getElementById("soundModeBox").style.display = "block";
        
        // Show splash logo
        document.getElementById("splashLogo").style.display = "block";
        
        // Show rocket overlay with button
        document.getElementById('rocketOverlay').style.display = 'block';
        
        // Set fixed background for level start screen
        setFixedSplashBackground();
        
        // Debug element visibility and positioning
        console.log('👁️ Element visibility check:');
        console.log(`  splashInfoBox: display=${splashInfoBox.style.display}, visible=${splashInfoBox.offsetWidth > 0}`);
        console.log(`  splashInfoBox position: bottom=${getComputedStyle(splashInfoBox).bottom}, right=${getComputedStyle(splashInfoBox).right}`);
        console.log(`  splashInfoBox z-index: ${getComputedStyle(splashInfoBox).zIndex}`);
        
        // Check for potentially interfering elements
        const highZElements = document.querySelectorAll('*');
        const interferingElements = [];
        highZElements.forEach(el => {
          const zIndex = parseInt(getComputedStyle(el).zIndex);
          const isVisible = el.offsetWidth > 0 && el.offsetHeight > 0;
          if (zIndex > 30 && isVisible) {
            interferingElements.push({element: el.tagName + (el.id ? `#${el.id}` : '') + (el.className ? `.${el.className}` : ''), zIndex});
          }
        });
        if (interferingElements.length > 0) {
          console.warn('⚠️ Elements with z-index > 30 (might interfere):', interferingElements);
        }
        
        // Check skill level buttons specifically
        const radioButtons = document.querySelectorAll('.radio-option');
        console.log('🎛️ Skill level button check:');
        radioButtons.forEach((button, i) => {
          const rect = button.getBoundingClientRect();
          const style = getComputedStyle(button);
          console.log(`  Button ${i}: visible=${rect.width > 0}, position=(${rect.left},${rect.top}), z-index=${style.zIndex}, pointer-events=${style.pointerEvents}`);
        });
        
        gameOverElement.style.display = "none";
        // Reset the upper-right status box values to starting values
        if (currentLevel === 1) {
          // Reset to initial game state values for Level 1
          summaryHeaderText.textContent = "LEVEL";
          summaryLevelNumber.textContent = "1";
          summaryBalloonPoints.textContent = "0";
          summaryStreakPoints.textContent = "0";
          summarySequencePoints.textContent = "0";
          summaryTotalPoints.textContent = "0";
          summaryTime.textContent = "0s";
          summaryLevelBalloons.textContent = "0";
          summaryStreak.textContent = "0";
          summaryPriorScore.textContent = "0";
          summaryGameScore.textContent = "0";
          summaryGameTime.textContent = "0s";
          summaryGameBalloons.textContent = "0";
          summaryLongestStreak.textContent = "0";
          
          // Show the reset status box
          gameSummaryElement.style.display = "block";
        } 
        updateTopTimer(); // Reset timer display

        // Background will be set when gameplay actually starts (in startLevel)

        // Show leaderboard before starting
        showLeaderboard();
      }

      // Start level function
      function startLevel() {
        waitingForStart = false;
        levelStartElement.style.display = "none";
        document.getElementById("splashInfoBox").style.display = "none"; // Hide info box during gameplay
        // Hide sound mode box during gameplay
        document.getElementById("soundModeBox").style.display = "none";
        // Hide splash logo during gameplay
        document.getElementById("splashLogo").style.display = "none";
        // Hide rocket overlay during gameplay
        document.getElementById('rocketOverlay').style.display = 'none';
        hideGameSummary(); // Hide game summary when starting
        hideLeaderboard();
        // Note: UI visibility will be handled by game state
        levelStartTime = performance.now();
        if (currentLevel === 1) {
          gameStartTime = performance.now();
          currentGameBalloons = 0;
          gameBalloonsPopped = 0; // Reset game stats for new game
          longestStreak = 0;
        }

        // Set random gameplay background for this level
        currentLevelBackground = selectRandomBackground();
        console.log(`Starting level ${currentLevel} with gameplay background:`, currentLevelBackground);
        applyBackgroundImage(currentLevelBackground);

        startGame();
      }

      // Create star field background
      function createStarField() {
        stars = [];
        const w = cssWidth(), h = cssHeight();
        const starDensity = 0.0002; // per pixel (CSS px)
        const starCount = Math.floor(w * h * starDensity);
        for (let i = 0; i < starCount; i++) {
          stars.push({
            x: Math.random() * w,
            y: Math.random() * h,
            brightness: Math.random() * 0.8 + 0.2,
            size: Math.random() * 2 + 1,
          });
        }
      }

      // Start/restart the game
      function startGame() {
        gameRunning = true;
        gameTime = getDifficultyTime(); // Dynamic time based on skill level
        levelEndsAt = performance.now() + gameTime * 1000;
        balloons = [];
        gameOverElement.style.display = "none";

        // Update UI displays - info now shown in upper-right status box
        updateScoreDisplay();
        updateStreakDisplay();
        updateSlotMachineDisplay();
        updateCursor();
        updateTopTimer();

        // Create balloons based on current level
        const balloonCount = getLevelBalloonCount(currentLevel);
        const sizeRange = getLevelBalloonSize(currentLevel);
        const colors = [
          "#FF6B6B",
          "#4ECDC4",
          "#45B7D1",
          "#96CEB4",
          "#FFEAA7",
          "#DDA0DD",
          "#98D8C8",
          "#F7DC6F",
          "#BB8FCE",
          "#85C1E9",
        ];

        // Reset sequence tracking for new level
        sequenceProgress = 0;
        maxSequenceNumber = 0;
        sequenceBroken = false;
        
        // Reset level scoring breakdown tracking
        levelBalloonPoints = 0;
        levelStreakPoints = 0;
        levelSequencePoints = 0;

        // First, create all balloons with their sizes
        const w = cssWidth(), h = cssHeight();
        const tempBalloons = [];
        for (let i = 0; i < balloonCount; i++) {
          const radius =
            Math.random() * (sizeRange.max - sizeRange.min) + sizeRange.min;
          const x = Math.random() * (w - radius * 2) + radius;
          const y = Math.random() * (h - radius * 2) + radius;
          const color = colors[Math.floor(Math.random() * colors.length)];

          tempBalloons.push({ x, y, radius, color });
        }

        // Sort balloons by size (radius) to identify mid-sized ones
        tempBalloons.sort((a, b) => a.radius - b.radius);

        // Determine which balloons get numbers (linear progression: level = number of balloons)
        // Level 1: 1 balloon (no bonus), Level 2: 2 balloons, ..., Level 10: 10 balloons
        let numberedBalloonIndices = [];
        if (currentLevel >= 1) {
          const smallestThird = Math.floor(balloonCount / 3);
          const availableForNumbers = tempBalloons.slice(smallestThird); // Exclude smallest 1/3
          const numberOfNumbered = currentLevel; // Level 1: 1, Level 2: 2, ..., Level 10: 10
          
          // Randomly select which of the available balloons get numbers
          const selectedIndices = [];
          while (selectedIndices.length < numberOfNumbered && selectedIndices.length < availableForNumbers.length) {
            const randomIndex = Math.floor(Math.random() * availableForNumbers.length);
            if (!selectedIndices.includes(randomIndex)) {
              selectedIndices.push(randomIndex);
            }
          }
          
          // Convert back to original balloon indices
          numberedBalloonIndices = selectedIndices.map(idx => idx + smallestThird);
          maxSequenceNumber = numberOfNumbered;
        }

        // Create the actual balloon objects
        for (let i = 0; i < tempBalloons.length; i++) {
          const balloon = tempBalloons[i];
          let number = null;
          
          // Assign sequential numbers to selected balloons
          if (numberedBalloonIndices.includes(i)) {
            number = numberedBalloonIndices.indexOf(i) + 1;
          }
          
          balloons.push(new Balloon(balloon.x, balloon.y, balloon.radius, balloon.color, number));
        }

        updateBalloonCount();
        gameLoop();
      }

      // Main game loop with performance timing
      function gameLoop(now = performance.now()) {
        if (!gameRunning) return;

        // Update timers
        updateTopTimer();
        const remaining = Math.max(0, Math.ceil((levelEndsAt - now) / 1000));
        // Timer info shown in top timer and upper-right status box

        const levelElapsedMs = now - levelStartTime;
        // Cumulative timer info shown in upper-right status box

        // End on timeout
        if (remaining === 0) { endGame(false); return; }

        // Clear & draw
        ctx.clearRect(0, 0, cssWidth(), cssHeight());
        
        // Only draw stars if using starfield fallback
        drawStars();
        
        updateBalloons();
        drawBalloons();

        animationId = requestAnimationFrame(gameLoop);
      }

      // Draw star field (only when using starfield fallback)
      function drawStars() {
        if (!usingStarfieldFallback) return; // Only draw stars when no background image
        
        for (const star of stars) {
          ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Update balloon positions and handle collisions
      function updateBalloons() {
        const w = cssWidth(), h = cssHeight();

        for (let i = balloons.length - 1; i >= 0; i--) {
          const b = balloons[i];

          if (b.popping) {
            b.popAnimation += 0.3;
            if (b.popAnimation >= 1) {
              balloons.splice(i, 1);
              updateBalloonCount();
              if (balloons.length === 0) endGame(true);
            }
            continue;
          }

          b.x += b.vx; b.y += b.vy;

          // Wall collisions (CSS px bounds)
          if (b.x - b.radius <= 0 || b.x + b.radius >= w) {
            b.vx = -b.vx;
            b.x = Math.max(b.radius, Math.min(w - b.radius, b.x));
          }
          if (b.y - b.radius <= 0 || b.y + b.radius >= h) {
            b.vy = -b.vy;
            b.y = Math.max(b.radius, Math.min(h - b.radius, b.y));
          }

          // Balloon-to-balloon collisions
          for (let j = i + 1; j < balloons.length; j++) {
            const o = balloons[j];
            if (o.popping) continue;

            const dx = b.x - o.x;
            const dy = b.y - o.y;
            const dist = Math.hypot(dx, dy);
            const minDist = b.radius + o.radius;

            if (dist < minDist && dist > 0) {
              // Separate overlap
              const overlap = minDist - dist;
              const nx = dx / dist, ny = dy / dist;
              const sepX = nx * (overlap * 0.5);
              const sepY = ny * (overlap * 0.5);
              b.x += sepX; b.y += sepY;
              o.x -= sepX; o.y -= sepY;

              // Relative velocity along normal
              const rvx = b.vx - o.vx;
              const rvy = b.vy - o.vy;
              const relSpeed = rvx * nx + rvy * ny;

              // FIX: resolve only if approaching (negative)
              if (relSpeed < 0) {
                // Elastic along normal (unit mass)
                b.vx -= relSpeed * nx;
                b.vy -= relSpeed * ny;
                o.vx += relSpeed * nx;
                o.vy += relSpeed * ny;

                // Renormalize to keep their individual speeds
                const ns1 = Math.hypot(b.vx, b.vy);
                const ns2 = Math.hypot(o.vx, o.vy);
                if (ns1 > 0) { b.vx = (b.vx / ns1) * b.individualSpeed; b.vy = (b.vy / ns1) * b.individualSpeed; }
                if (ns2 > 0) { o.vx = (o.vx / ns2) * o.individualSpeed; o.vy = (o.vy / ns2) * o.individualSpeed; }
              }
            }
          }
        }
      }

      // Draw balloons with strings
      function drawBalloons() {
        for (const balloon of balloons) {
          if (balloon.popping) {
            // Pop animation - stretch and squash
            const scale =
              balloon.popAnimation < 0.3
                ? 1 - balloon.popAnimation * 2 // Shrink
                : 1 + (balloon.popAnimation - 0.3) * 8; // Explode

            if (balloon.popAnimation < 0.7) {
              ctx.save();
              ctx.translate(balloon.x, balloon.y);
              ctx.scale(scale, scale);

              // Draw balloon
              ctx.fillStyle = balloon.color;
              ctx.beginPath();
              ctx.arc(0, 0, balloon.radius, 0, Math.PI * 2);
              ctx.fill();

              ctx.restore();
            }
          } else {
            // Draw string (longer, thicker, colored wavy line)
            ctx.strokeStyle = balloon.stringColor;
            ctx.lineWidth = Math.max(4, balloon.radius * 0.12); // Thicker, scales with balloon size
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.beginPath();
            ctx.moveTo(balloon.x, balloon.y + balloon.radius);

            const stringLength = balloon.radius * 1.5; // Longer strings
            const segments = 12; // More segments for smoother curves
            for (let i = 1; i <= segments; i++) {
              const t = i / segments;
              const waveIntensity = 4 + balloon.radius * 0.1; // Wave intensity scales with balloon
              const x = balloon.x + Math.sin(t * Math.PI * 4) * waveIntensity;
              const y = balloon.y + balloon.radius + t * stringLength;
              ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw balloon
            ctx.fillStyle = balloon.color;
            ctx.beginPath();
            ctx.arc(balloon.x, balloon.y, balloon.radius, 0, Math.PI * 2);
            ctx.fill();

            // Add highlight
            ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
            ctx.beginPath();
            ctx.arc(
              balloon.x - balloon.radius * 0.3,
              balloon.y - balloon.radius * 0.3,
              balloon.radius * 0.3,
              0,
              Math.PI * 2
            );
            ctx.fill();

            // Draw number if balloon has one (Toy Story style)
            if (balloon.number !== null) {
              ctx.save();
              
              // Calculate font size based on balloon radius (fit comfortably inside)
              const fontSize = Math.max(14, balloon.radius * 0.6);
              
              // Toy Story style font with bold, playful appearance
              ctx.font = `bold ${fontSize}px "Comic Sans MS", "Arial Black", sans-serif`;
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              
              // Multi-layer text for toy-like appearance with strong contrast
              const numberText = balloon.number.toString();
              
              // Extra thick black outline for maximum visibility
              ctx.strokeStyle = "#000000";
              ctx.lineWidth = Math.max(4, fontSize * 0.2);
              ctx.strokeText(numberText, balloon.x, balloon.y);
              
              // Medium black outline (second layer)
              ctx.strokeStyle = "#000000";
              ctx.lineWidth = Math.max(3, fontSize * 0.15);
              ctx.strokeText(numberText, balloon.x, balloon.y);
              
              // White inner outline for extra contrast
              ctx.strokeStyle = "#FFFFFF";
              ctx.lineWidth = Math.max(2, fontSize * 0.08);
              ctx.strokeText(numberText, balloon.x, balloon.y);
              
              // Colorful fill based on number (bright, playful colors)
              const numberColors = [
                "#FF0000", // 1 - Red
                "#00FF00", // 2 - Green  
                "#0000FF", // 3 - Blue
                "#FFFF00", // 4 - Yellow
                "#FF00FF", // 5 - Magenta
                "#00FFFF", // 6 - Cyan
                "#FF8000", // 7 - Orange
                "#8000FF", // 8 - Purple
                "#FF0080", // 9 - Pink
                "#80FF00"  // 10+ - Lime
              ];
              ctx.fillStyle = numberColors[(balloon.number - 1) % numberColors.length];
              ctx.fillText(numberText, balloon.x, balloon.y);
              
              ctx.restore();
            }
          }
        }
      }

      // Scoring helper functions
      function calculateLevelPoints(level) {
        return Math.pow(10, level - 1); // 1, 10, 100, 1000, etc.
      }
      
      function calculateSequenceBonus(level) {
        // Exponential bonus: 10^(level+1) starting at level 2
        // Level 2: 10^3 = 1,000, Level 3: 10^4 = 10,000, etc.
        if (level < 2) return 0; // No sequence bonuses for level 1
        return Math.pow(10, level + 1);
      }
      
      function processHit(hitBalloon = null) {
        // Calculate base points for this level
        const basePoints = calculateLevelPoints(currentLevel);
        let pointsEarned = basePoints;
        let streakBonus = 0;
        let sequenceBonus = 0;
        
        // Track balloon points
        levelBalloonPoints += basePoints;
        gameBalloonsPopped++; // Track total game balloons
        
        // Increment consecutive hits
        consecutiveHits++;
        
        // Update longest streak if current streak is longer
        if (consecutiveHits > longestStreak) {
          longestStreak = consecutiveHits;
        }
        
        // Check for streak bonus (5+ consecutive hits)
        if (consecutiveHits >= 5) {
          streakBonus = basePoints * 10; // 10x level points
          pointsEarned += streakBonus;
          levelStreakPoints += streakBonus; // Track streak points
          console.log(`Streak bonus! ${consecutiveHits} consecutive hits = +${streakBonus} points`);
        }
        
        // Check for sequence bonus (if balloon has a number and sequence isn't broken)
        if (hitBalloon && hitBalloon.number !== null && !sequenceBroken) {
          const expectedNumber = sequenceProgress + 1;
          
          console.log(`🔢 Sequence check: Hit #${hitBalloon.number}, Expected #${expectedNumber}, Progress: ${sequenceProgress}`);
          
          if (hitBalloon.number === expectedNumber) {
            // Correct sequence! Update progress
            sequenceProgress++;
            
            // Only award bonus points for balloon #2 and above (not #1)
            if (hitBalloon.number >= 2) {
              sequenceBonus = calculateSequenceBonus(currentLevel);
              pointsEarned += sequenceBonus;
              levelSequencePoints += sequenceBonus; // Track sequence points
              console.log(`✅ Sequence bonus! Hit #${hitBalloon.number} in order = +${sequenceBonus} points (Total sequence points: ${levelSequencePoints})`);
            } else {
              console.log(`✅ Sequence started! Hit #1 - no bonus points yet, but sequence is active`);
            }
          } else {
            // Sequence broken permanently!
            sequenceBroken = true;
            if (sequenceProgress === 0) {
              console.log(`💥 Sequence PERMANENTLY broken! Started with #${hitBalloon.number} instead of #1 - no sequence bonuses this level`);
            } else {
              console.log(`💥 Sequence PERMANENTLY broken! Hit #${hitBalloon.number} but expected #${expectedNumber} - no more sequence bonuses this level`);
            }
          }
        } else if (hitBalloon && hitBalloon.number !== null && sequenceBroken) {
          console.log(`🚫 Sequence already broken - no bonus for hitting #${hitBalloon.number}`);
        }
        
        // Add to total score
        currentScore += pointsEarned;
        
        // Add 1 second to timer
        levelEndsAt += 1000; // Add 1000ms (1 second)
        
        console.log(`Hit! +${pointsEarned} points (Level ${currentLevel}, Streak: ${consecutiveHits})`);
        
        // Update displays
        updateScoreDisplay();
        updateStreakDisplay();
        updateSlotMachineDisplay();
        updateCursor();
        
        return pointsEarned;
      }
      
      function processMiss() {
        // Record completed streak if it was 5+
        if (consecutiveHits >= 5) {
          currentStreakList.push(consecutiveHits);
          console.log(`Streak ended: ${consecutiveHits} consecutive hits`);
        }
        
        // Reset consecutive hits
        consecutiveHits = 0;
        console.log('Miss! Streak reset to 0');
        
        // Update displays
        updateStreakDisplay();
        updateCursor();
      }
      
      // Display update functions
      function updateScoreDisplay() {
        // Score info shown in slot machine display and upper-right status box
      }
      
      function updateStreakDisplay() {
        // Streak info shown in upper-right status box
      }
      
      // ============================================================================
      // SLOT MACHINE SCORING SYSTEM
      // ============================================================================
      
      // Initialize simplified spinning score display
      function initializeScoreDisplay() {
        const maxDigits = 15; // Handles up to 999 trillion
        scoreDigitsElement.innerHTML = '';
        digitContainers = [];
        
        for (let i = 0; i < maxDigits; i++) {
          // Add comma separator every 3 digits (from right)
          if (i > 0 && i % 3 === 0) {
            const comma = document.createElement('div');
            comma.className = 'comma-separator';
            comma.textContent = ',';
            scoreDigitsElement.appendChild(comma);
          }
          
          const container = document.createElement('div');
          container.className = 'digit-container';
          
          const window = document.createElement('div');
          window.className = 'digit-window';
          
          const wheel = document.createElement('div');
          wheel.className = 'digit-wheel';
          
          // Create 10 digits for the wheel (0-9)
          for (let digit = 0; digit <= 9; digit++) {
            const digitElement = document.createElement('div');
            digitElement.className = 'digit-number';
            digitElement.textContent = digit;
            wheel.appendChild(digitElement);
          }
          
          window.appendChild(wheel);
          container.appendChild(window);
          scoreDigitsElement.appendChild(container);
          
          digitContainers.push({container, wheel}); // Store in correct order (left to right)
        }
      }
      
      // Roll individual wheel to target number with settling effect
      function rollDigit(digitObj, targetDigit, delay = 0) {
        setTimeout(() => {
          const wheel = digitObj.wheel;
          const targetPosition = -targetDigit * 80; // 80px per digit
          
          // First spin past the target (overshoot)
          const overshoot = targetPosition - 40; // Go 40px past
          wheel.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
          wheel.style.transform = `translateY(${overshoot}px)`;
          
          // Then settle back to final position with bounce
          setTimeout(() => {
            wheel.style.transition = 'transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
            wheel.style.transform = `translateY(${targetPosition}px)`;
          }, 800);
          
        }, delay);
      }
      
      // Update score display with rolling animation
      function updateSlotMachineDisplay() {
        const scoreStr = currentScore.toString().padStart(15, '0');
        const previousStr = previousScore.toString().padStart(15, '0');
        
        console.log(`Score update: ${previousScore.toLocaleString()} → ${currentScore.toLocaleString()}`);
        
        // Find which digits changed and animate them
        for (let i = 0; i < 15; i++) {
          const currentDigit = parseInt(scoreStr[i]);
          const previousDigit = parseInt(previousStr[i]);
          
          if (currentDigit !== previousDigit) {
            // Add small delay based on position for cascading effect
            const delay = (14 - i) * 50; // Right-most digits first
            console.log(`Position ${i}: ${previousDigit} → ${currentDigit} (delay: ${delay}ms)`);
            rollDigit(digitContainers[i], currentDigit, delay);
          }
        }
        
        
        previousScore = currentScore;
      }
      
      // Update custom cursor based on streak
      function updateCursor() {
        if (consecutiveHits >= 5) {
          // Show streak cursor with number below pointer
          customCursor.innerHTML = `
            <div class="cursor-streak">
              <div class="streak-pointer"></div>
              <div class="streak-number">${consecutiveHits}</div>
            </div>
          `;
        } else {
          // Show regular sharp pointer
          customCursor.innerHTML = '<div class="cursor-pointer"></div>';
        }
      }
      
      // Handle mouse movement for custom cursor
      function handleMouseMove(event) {
        // Position cursor so its top edge (where triangle tip is) aligns with mouse coordinates
        customCursor.style.left = event.clientX + 'px';
        customCursor.style.top = event.clientY + 'px';
      }
      
      // Debug function to analyze cursor positioning
      window.debugCursorPosition = function() {
        console.log('🎯 === CURSOR POSITION ANALYSIS ===');
        
        const rect = customCursor.getBoundingClientRect();
        const style = getComputedStyle(customCursor);
        
        console.log('📦 Cursor Element:');
        console.log(`   Position: (${rect.left}, ${rect.top})`);
        console.log(`   Size: ${rect.width}x${rect.height}`);
        console.log(`   Transform: ${style.transform}`);
        console.log(`   Top style: ${customCursor.style.top}`);
        console.log(`   Left style: ${customCursor.style.left}`);
        
        console.log('🔺 Cursor Content:');
        console.log(`   HTML: ${customCursor.innerHTML}`);
        
        // Check for any margins/padding on triangle elements
        const triangles = customCursor.querySelectorAll('.cursor-pointer, .streak-pointer');
        triangles.forEach((triangle, i) => {
          const tStyle = getComputedStyle(triangle);
          console.log(`   Triangle ${i}: margin=${tStyle.margin}, padding=${tStyle.padding}`);
        });
        
        console.log('🎯 === END ANALYSIS ===');
      };
      
      // Keep cursor always visible (removed enter/leave handlers that caused flickering)
      
      // ============================================================================
      // SCORE DISPLAY SYSTEM
      // ============================================================================
      
      // Note: updateSlotMachineDisplay() is defined above with slot machine animation
      
      // Update top level display
      function updateTopLevel() {
        levelNumberElement.textContent = currentLevel;
      }

      // Update top timer display with color coding
      function updateTopTimer() {
        if (!gameRunning) {
          topTimerElement.textContent = getDifficultyTime();
          topTimerElement.className = '';
          return;
        }
        
        const remaining = Math.max(0, Math.ceil((levelEndsAt - performance.now()) / 1000));
        topTimerElement.textContent = remaining;
        
        // Update timer color based on remaining time
        topTimerElement.className = '';
        if (remaining <= 3) {
          topTimerElement.classList.add('critical');
        } else if (remaining <= 7) {
          topTimerElement.classList.add('warning');
        }
      }
      
      // ============================================================================
      // CHEAT SYSTEM
      // ============================================================================
      
      // Cheat function: Pop a random balloon (ALT-P)
      function cheatPopRandomBalloon() {
        // Only work during active gameplay
        if (!gameRunning) {
          console.log('🎮 Cheat ignored: Game not running');
          return;
        }
        
        // Find all active (non-popping) balloons
        const activeBalloons = balloons.filter((b) => !b.popping);
        
        if (activeBalloons.length === 0) {
          console.log('🎮 Cheat ignored: No active balloons to pop');
          return;
        }
        
        let targetBalloon = null;
        
        // First priority: Find the next balloon in sequence
        const nextSequenceNumber = sequenceProgress + 1;
        const sequenceBalloon = activeBalloons.find(b => b.number === nextSequenceNumber);
        
        if (sequenceBalloon) {
          targetBalloon = sequenceBalloon;
          console.log(`🎯 Cheat: Popping sequence balloon #${nextSequenceNumber}`);
        } else {
          // No sequence balloon available, pop any random balloon
          const randomIndex = Math.floor(Math.random() * activeBalloons.length);
          targetBalloon = activeBalloons[randomIndex];
          
          if (targetBalloon.number !== null) {
            console.log(`🎮 Cheat: Popping numbered balloon #${targetBalloon.number} (out of sequence)`);
          } else {
            console.log('🎮 Cheat: Popping regular balloon');
          }
        }
        
        // Apply popping logic (same as normal click)
        targetBalloon.popping = true;
        targetBalloon.popAnimation = 0;
        currentGameBalloons++;
        
        // Process the hit for scoring
        processHit(targetBalloon);
        
        // Mark as cheater and update the skill box text
        cheaterFlag = true;
        const cheatText = document.getElementById('cheatInfoText');
        cheatText.textContent = 'CHEATER!';
        cheatText.classList.add('cheater-active');
        
        console.log('🎮 Cheat activated: Random balloon popped!');
      }


      // Handle mouse clicks (CSS px coords)
      canvas.addEventListener("click", (event) => {
        if (!gameRunning) return;

        const rect = canvas.getBoundingClientRect();
        // With DPR transform set, internal coords are CSS px:
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        let hitBalloon = false;
        
        for (const b of balloons) {
          if (b.popping) continue;
          const dx = x - b.x, dy = y - b.y;
          const distance = Math.hypot(dx, dy);

          const minClickRadius = 15;
          const clickRadius = Math.max(b.radius, minClickRadius);
          const radiusBonus = Math.min(clickRadius - b.radius, b.radius * 0.3);
          const effectiveRadius = b.radius + radiusBonus;

          if (distance <= effectiveRadius) {
            b.popping = true;
            b.popAnimation = 0;
            currentGameBalloons++;
            
            // Process the hit for scoring
            processHit(b);
            hitBalloon = true;
            break;
          }
        }
        
        // If no balloon was hit, process as a miss
        if (!hitBalloon) {
          processMiss();
        }
      });

      // Update balloon count display
      function updateBalloonCount() {
        const activeBalloons = balloons.filter((b) => !b.popping).length;
        // Balloon count info shown in upper-right status box
      }

      // Victory celebration animation for completing level 10
      function playVictoryCelebration() {
        const logo = document.getElementById("splashLogo");
        
        // Initial 2-second delay before starting celebration
        setTimeout(() => {
          // Phase 1: Bring to foreground and slowly ease to center
          logo.style.zIndex = "9999"; // Highest z-index (foreground)
          logo.style.animation = "logo-to-center-transform 2.5s ease-in forwards"; // Slow ease-in
          
          // Phase 2: Spin 5 times with smooth acceleration (after 2.5s)
          setTimeout(() => {
            logo.style.animation = "logo-spin-smooth 3s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards";
            // Play victory fanfare during spinning (respects sound mode)
            playVictoryFanfare();
          }, 2500);
          
          // Phase 3: Wait 1s, then return home (after 6.5s total)
          setTimeout(() => {
            logo.style.animation = "logo-return-home-transform 2s ease-in-out forwards";
          }, 6500);
          
          // Phase 4: Reset z-index to original (after 8.5s total)
          setTimeout(() => {
            logo.style.zIndex = "15"; // Back to original (behind game elements)
            logo.style.animation = ""; // Clear animation
          }, 8500);
        }, 2000); // 2-second initial delay
      }

      function endGame(playerWon) {
        gameRunning = false;
        if (animationId) cancelAnimationFrame(animationId);
        
        // Clear all balloons from screen
        balloons = [];
        ctx.clearRect(0, 0, cssWidth(), cssHeight());

        const levelTime = performance.now() - levelStartTime;
        cumulativeTime += levelTime;
        // Cumulative timer info shown in upper-right status box

        if (playerWon) {
          if (currentLevel < 10) {
            // Show level completion summary before advancing
            showGameSummary(levelTime);
            
            // Advance to next level
            currentLevel++;
            updateTopLevel(); // Update level display
            console.log(`Level up! Advancing to Level ${currentLevel}, maintaining streak of ${consecutiveHits} hits`);
            gameOverText.innerHTML = `Level ${
              currentLevel - 1
            } Complete!<br>Moving to Level ${currentLevel}`;
            gameOverText.style.color = "#4CAF50";

            // Auto-advance to next level after 2 seconds
            setTimeout(() => {
              gameOverElement.style.display = "none";
              // Ensure skill level box is visible during transition
              document.getElementById("splashInfoBox").style.display = "block";
              // Show sound mode box during transition
              document.getElementById("soundModeBox").style.display = "block";
              showLevelStart();
            }, 2000);
          } else {
            // Game completed! Show final level summary
            showGameSummary(levelTime, true);
            
            // Save game to leaderboard and show updated leaderboard
            saveGameToLeaderboard();
            showLeaderboard();
            
            gameOverText.innerHTML = `🎉 Game Complete! 🎉<br>All 10 levels finished!<br>Total Time: ${Math.floor(
              cumulativeTime / 1000
            )}s`;
            gameOverText.style.color = "#FFD700";
            gameOverElement.style.display = "block";
            // Show splash logo on victory screen
            document.getElementById("splashLogo").style.display = "block";
            // Start victory celebration animation
            playVictoryCelebration();
            // Set fixed background for the victory screen
            setFixedSplashBackground();
          }
        } else {
          // Game failed! Show final level summary
          showGameSummary(levelTime, true);
          
          // Save game to leaderboard and show updated leaderboard
          saveGameToLeaderboard();
          showLeaderboard();
          
          gameOverText.innerHTML = `GAME OVER!`;
          gameOverText.style.color = "#FF6B6B";
          gameOverElement.style.display = "block";
          // Show skill level box on game over screen
          document.getElementById("splashInfoBox").style.display = "block";
          // Show sound mode box on game over screen
          document.getElementById("soundModeBox").style.display = "block";
          // Show splash logo on game over screen
          document.getElementById("splashLogo").style.display = "block";
          // Set fixed background for the game over screen
          setFixedSplashBackground();
        }
      }

      // Reset game to level 1
      function resetGame() {
        // Game scores are already saved to leaderboard in endGame()

        // Reset to Level 1 (restart entire game)
        currentLevel = 1;
        
        // Reset cheater flag and text for new game
        cheaterFlag = false;
        const cheatText = document.getElementById('cheatInfoText');
        cheatText.textContent = 'ALT-P(op) for cheat';
        cheatText.classList.remove('cheater-active');
        
        // Reset cumulative game variables
        cumulativeTime = 0;
        currentGameBalloons = 0;
        gameBalloonsPopped = 0;
        longestStreak = 0;
        
        // Reset scoring variables
        currentScore = 0;
        previousScore = 0;
        consecutiveHits = 0;
        currentStreakList = [];
        
        // Reset level scoring breakdown tracking
        levelBalloonPoints = 0;
        levelStreakPoints = 0;
        levelSequencePoints = 0;
        
        // Reset sequence bonus system
        sequenceProgress = 0;
        maxSequenceNumber = 0;
        sequenceBroken = false;
        
        // Reset game state flags
        gameRunning = false;
        waitingForStart = true;
        
        // Clear balloons and canvas (same as initial game boot)
        balloons = [];
        ctx.clearRect(0, 0, cssWidth(), cssHeight());
        
        // Reset background to fixed splash background
        setFixedSplashBackground();
        
        // Reset slot machine display - force all digits to show 0
        // First reinitialize the odometer structure
        initializeScoreDisplay();
        // Then update displays
        updateSlotMachineDisplay();
        updateCursor();
        updateTopTimer();
        updateTopLevel(); // Fix: Update level display to show 1
        
        // Start the level (keeping the same level number)
        showLevelStart();
      }

      // Statistics and leaderboard functions
      function loadStatistics() {
        const stats = localStorage.getItem("balloonGameStats");
        if (stats) {
          const parsed = JSON.parse(stats);
          totalBalloonsPopped = parsed.totalBalloonsPopped || 0;
          totalStreaks = parsed.totalStreaks || 0;
        }
      }

      function saveStatistics() {
        const stats = {
          totalBalloonsPopped: totalBalloonsPopped,
          totalStreaks: totalStreaks,
          totalTimePlayed:
            parseInt(localStorage.getItem("balloonGameTotalTime") || "0") +
            Math.floor(cumulativeTime / 1000),
        };
        localStorage.setItem("balloonGameStats", JSON.stringify(stats));
        localStorage.setItem(
          "balloonGameTotalTime",
          stats.totalTimePlayed.toString()
        );
      }

      function saveGameToLeaderboard() {
        // Add any remaining streak if game ended during a streak
        let finalStreakList = [...currentStreakList];
        if (consecutiveHits >= 5) {
          finalStreakList.push(consecutiveHits);
        }
        
        const gameData = {
          score: currentScore,
          level: currentLevel,
          balloons: currentGameBalloons,
          time: Math.floor(cumulativeTime / 1000),
          streaks: finalStreakList,
          date: new Date().toLocaleDateString(),
          cheater: cheaterFlag,
        };

        let leaderboard = JSON.parse(
          localStorage.getItem("balloonGameLeaderboard") || "[]"
        );
        leaderboard.push(gameData);

        // Sort by score (descending) - highest score first
        leaderboard.sort((a, b) => {
          return (b.score || 0) - (a.score || 0); // Handle old entries without score
        });

        // Keep only top 5
        leaderboard = leaderboard.slice(0, 5);
        localStorage.setItem(
          "balloonGameLeaderboard",
          JSON.stringify(leaderboard)
        );

        // Update total statistics
        totalBalloonsPopped += currentGameBalloons;
        totalStreaks += finalStreakList.length; // Add number of 5+ streaks achieved
        saveStatistics();
      }

      function showLeaderboard() {
        loadStatistics();

        // Update leaderboard in the new bottom-left box
        const leaderboard = JSON.parse(
          localStorage.getItem("balloonGameLeaderboard") || "[]"
        );
        const leaderboardList = document.getElementById("leaderboardList");

        if (leaderboard.length === 0) {
          leaderboardList.innerHTML =
            '<div style="color: #888;">No games completed yet</div>';
        } else {
          leaderboardList.innerHTML = leaderboard
            .map(
              (game, index) => {
                const score = (game.score || 0).toLocaleString();
                const streaksText = game.streaks && game.streaks.length > 0 ? 
                  game.streaks.join(", ") : "None";
                const cheaterText = game.cheater ? ' <span style="color:#FF0000; font-weight:normal;">Cheater!</span>' : '';
                return `<div class="leaderboard-entry">
                        #${index + 1} - ${score} pts | Level ${game.level} | ${
                  game.balloons
                } balloons | ${game.time}s${cheaterText}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Streaks: ${streaksText} | ${game.date}
                    </div>`;
              }
            )
            .join("");
        }

        document.getElementById("leaderboardBox").style.display = "block";
      }

      // Reset high scores function
      function resetHighScores() {
        if (confirm("Are you sure you want to reset all high scores? This cannot be undone.")) {
          localStorage.removeItem("balloonGameLeaderboard");
          localStorage.removeItem("balloonGameStats");
          localStorage.removeItem("balloonGameTotalTime");
          alert("High scores have been reset!");
          console.log("🗑️ High scores and statistics cleared");
          
          // Refresh the leaderboard display if it's currently shown
          if (document.getElementById("leaderboardBox").style.display === "block") {
            showLeaderboard();
          }
        }
      }

      // Show game summary with comprehensive statistics
      function showGameSummary(levelTime, isGameOver = false) {
        // Set fixed background for level completion summary
        setFixedSplashBackground();
        
        const totalLevelPoints = levelBalloonPoints + levelStreakPoints + levelSequencePoints;
        const totalGameTime = performance.now() - gameStartTime;
        
        // Populate the comprehensive summary box
        if (isGameOver) {
          summaryHeaderText.textContent = "FINAL STATS";
        } else {
          summaryHeaderText.textContent = "LEVEL CLEARED!";
        }
        summaryLevelNumber.textContent = currentLevel; // Current level that was just completed
        summaryBalloonPoints.textContent = levelBalloonPoints.toLocaleString();
        summaryStreakPoints.textContent = levelStreakPoints.toLocaleString();
        summarySequencePoints.textContent = levelSequencePoints.toLocaleString();
        summaryTotalPoints.textContent = totalLevelPoints.toLocaleString();
        
        // Level stats
        summaryTime.textContent = Math.floor(levelTime / 1000) + "s";
        summaryLevelBalloons.textContent = currentGameBalloons; // Balloons popped in this level
        summaryStreak.textContent = consecutiveHits;
        
        // Game stats
        const priorScore = currentScore - totalLevelPoints;
        summaryPriorScore.textContent = priorScore.toLocaleString();
        summaryGameScore.textContent = currentScore.toLocaleString();
        summaryGameTime.textContent = Math.floor(totalGameTime / 1000) + "s";
        summaryGameBalloons.textContent = gameBalloonsPopped;
        summaryLongestStreak.textContent = longestStreak;
        
        // Show the summary box and hide the game UI (stays visible until start button is clicked)
        gameSummaryElement.style.display = "block";
      }

      function hideGameSummary() {
        gameSummaryElement.style.display = "none";
      }

      function hideLeaderboard() {
        document.getElementById("leaderboardBox").style.display = "none";
      }


      // Debug function to manually test background
      window.debugBackground = function(imageName) {
        console.log('Manual background test for:', imageName);
        applyBackgroundImage(imageName);
      };
      
      // Debug function to show current state
      window.debugState = function() {
        console.log('=== GAME STATE DEBUG ===');
        console.log('Current Level:', currentLevel);
        console.log('Current Score:', currentScore.toLocaleString());
        console.log('Consecutive Hits:', consecutiveHits);
        console.log('Current Game Streaks (5+):', currentStreakList);
        console.log('Total Balloons Popped:', currentGameBalloons);
        console.log('Game Running:', gameRunning);
        console.log('Available backgrounds:', availableBackgrounds.length);
        console.log('Current background:', currentLevelBackground);
        console.log('========================');
      };
      
      // Debug function to simulate hits/misses for testing
      window.debugHit = function() {
        if (!gameRunning) {
          console.log('Game not running! Start a level first.');
          return;
        }
        processHit(); // Debug version doesn't specify balloon
        console.log(`Debug hit processed. Score: ${currentScore}, Streak: ${consecutiveHits}`);
      };
      
      window.debugMiss = function() {
        if (!gameRunning) {
          console.log('Game not running! Start a level first.');
          return;
        }
        processMiss();
        console.log(`Debug miss processed. Streak reset. Completed streaks: ${currentStreakList}`);
      };
      
      // Debug function to test URL parameters manually
      window.debugUrlParams = function() {
        console.log('🔧 URL Parameter Debug Info:');
        console.log('Current URL:', window.location.href);
        const params = parseUrlParams();
        console.log('Parsed parameters:', params);
        console.log('Current game state:');
        console.log('  Level:', currentLevel);
        console.log('  Score:', currentScore.toLocaleString());
        console.log('  Streak:', consecutiveHits);
        console.log('');
        console.log('💡 Example URLs:');
        console.log('  Start at level 5: TSBalloonie.html?level=5');
        console.log('  Start with 1M points: TSBalloonie.html?score=1000000');
        console.log('  Level 8 with 50M points: TSBalloonie.html?level=8&score=50000000');
      };
      
      // Debug function to test cheat manually
      window.debugCheat = function() {
        console.log('🎮 Testing ALT-P cheat manually...');
        cheatPopRandomBalloon();
      };
      
      // Debug function to test sequence scoring calculations
      window.debugSequenceScoring = function() {
        console.log('🔢 Sequence Scoring Analysis:');
        for (let level = 1; level <= 10; level++) {
          const basePoints = calculateLevelPoints(level);
          const sequenceBonus = calculateSequenceBonus(level);
          const balloonCount = getLevelBalloonCount(level);
          const numberedBalloons = level; // Level 1: 1, Level 2: 2, ..., Level 10: 10
          const maxSequencePoints = numberedBalloons * sequenceBonus;
          
          console.log(`Level ${level}: Base=${basePoints}, SeqBonus=${sequenceBonus}, MaxSeq=${maxSequencePoints}`);
        }
        
        // Calculate Level 10 theoretical maximum
        const level10Regular = 241000000000; // Approximate from continuation file
        const level10SequenceMax = 10 * calculateSequenceBonus(10); // 10 numbered balloons at level 10
        const level10Total = level10Regular + level10SequenceMax;
        
        console.log(`\n🎯 Level 10 Theoretical Maximum:`);
        console.log(`Regular scoring: ~${(level10Regular / 1000000000).toFixed(1)}B`);
        console.log(`Sequence scoring: ~${(level10SequenceMax / 1000000000).toFixed(1)}B`);
        console.log(`Total: ~${(level10Total / 1000000000).toFixed(1)}B`);
        console.log(`Target achieved: ${level10Total >= 1000000000000 ? '✅' : '❌'}`);
      };

      // Debug function to show all available commands
      window.debugHelp = function() {
        console.log('🔧 Available Debug Commands:');
        console.log('  debugState() - Show current game state');
        console.log('  debugHit() - Simulate a hit');
        console.log('  debugMiss() - Simulate a miss');
        console.log('  debugCheat() - Test ALT-P cheat');
        console.log('  debugUrlParams() - Show URL parameter info');
        console.log('  debugBackground(filename) - Test background image');
        console.log('  debugSequenceScoring() - Analyze sequence scoring potential');
        console.log('');
        console.log('🎮 Cheat Codes:');
        console.log('  ALT-P during gameplay - Pop random balloon');
      };

      // Initialize the game when page loads
      window.addEventListener("load", init);
    </script>
    </div>
  </body>
</html>
